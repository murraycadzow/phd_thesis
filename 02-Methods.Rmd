# Methods and data
```{r, echo = FALSE, message = FALSE, warning= FALSE}
library(tidyverse)
library(pander)
library(kableExtra)
library(phdFunctions)
source("scripts/methods_tables.R")
panel <- read.table('~/data/NZ_coreExome_1kgp/nz_1kgp.panel', header = TRUE, stringsAsFactors = FALSE)
markers <- read.table('~/data/NZ_coreExome_1kgp/nz_1kg_markers.txt', stringsAsFactors = FALSE, header = FALSE)
names(markers) <- c("chrom","chrom_start","marker","ref","alt")
```

```{r, echo = FALSE, inlcude = FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

```{r, linewidth=80, tidy=TRUE, include = FALSE, eval=FALSE}
# this is an example of how linewidth will cut the output short, however it doesn't wrap the code chunk
a <- '## "stx2A; shiga-like toxin II A subunit encoded by bacteriophage BP-933W; K11006 shiga toxin subunit A" '
a
```

This chapter describes the methods and datasets used in this thesis. Section \@ref(methods) covers the methods used for the preparation of the datasets, such as haplotype phasing, \gls{pca}, and file format conversions, as well as the methods used for the analysis of the datasets, such as the calculation of selection statistics. Section \@ref(datasets) contains a description of the two main data sources that were used and how they were transformed for the analysis.


## Methods {#methods}

All genomic resources and co-ordinates reported in this project use the human genome reference build GRCh37, unless otherwise specified.

### Phasing {#phase}

Haplotype phasing is a method of establishing the parental origin of haplotypes. It looks for the co-location of alleles to form haplotypes. In diploids such as humans, there is a maternal and a paternal haplotype at any given position in the genome. Selection statistics such as \gls{ihs} require phased data in order to calculate the degradation of haplotypes by recombination. Phasing can be performed through the use of trios (parents and offspring), or it can be done through probabilistic phasing using large population haplotype reference panels (such as created from the \gls{1kgp}, see section \@ref(1kgpdesc) and Table \@ref(tab:refDatasets)) and probabilistically determining the most likely haplotype(s) for an individual given a set of markers.

Phasing was performed using SHAPEIT2 v2.r837 [@Delaneau2013] using the \gls{1kgp} reference haplotype panel (Table \@ref(tab:refDatasets)). There were two steps involved for phasing of genotypes. The first was to check the markers in each data set were matched with the markers in the reference haplotypes. Markers were marked for exclusion by this step for reasons such as the marker not being in the reference panel, or if the marker had different allele types to that in the reference panel. An example of this step is provided in the following code.

```{bash, eval = FALSE, echo =TRUE}
# Check alignment of markers against reference haplotypes
# ? = chromosome
shapeit2 \
-check \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
  --output-log coreExome_norm.chr?.checked \
  -T 12
```

The second step was the phasing of genotypes into their haplotypes by using the \gls{1kgp} phased haplotype reference and a genetic map that was provided as part of the reference files. Markers that were marked for exclusion from the previous step were excluded. The most likely pair of haplotypes were outputted. The haplotypes were then converted from the haps format^[https://mathgen.stats.ox.ac.uk/genetics_software/shapeit/shapeit.html#formats] into a phased \gls{vcf}^[https://samtools.github.io/hts-specs/VCFv4.2.pdf]. These two steps are shown in the following code.

```{bash, eval = FALSE, echo = TRUE}
# Run phasing against reference haplotypes
# Exclude misaligned markers
# Use 8 threads
# ? = chromosome
shapeit2 \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
--output-max coreExome_norm.chr?.phased \
--exclude-snp coreExome_norm.chr?.checked.snp.strand.exclude \
-T 8

# Convert haps to vcf
shapeit2 \
-convert \
--input-haps coreExome_norm.chr?.phased \
--output-vcf coreExome_norm.chr?.phased.vcf 
```




### Selection Statistics

#### PopGenome {#popgenomeMethods}

The PopGenome package (v2.2.3, @Pfeifer2014) for R was used for the calculation of \gls{td}, \gls{fwh}, \gls{flf}, and \gls{ze}. Popgenome calculates the D\* and F\* version from @Fu1993 which do not require an outgroup that should be a closely related population or species. The selection and neutrality statistics were calculated using a sliding window approach with a window size of 100 kb and a slide of 10 kb. Windows that had fewer than four segregating sites were filtered out, and window co-ordinates were altered to be +/- 5 kb from the centre of the window. The empirical distribution for each statistic, for each population, was used to create a significance threshold. The lower threshold was $min$(1^st^ percentile, 0). The upper significance threshold was $max$(99^th^ percentile, 0). The greater or less than zero condition was to enable the interpretation of the selection and neutrality statistic results, as zero is the point at which these statistics indicate an excess or deficit of a particular allele frequency category. F~ST~ was also calculated in the same sliding window setup, and pair-wise between the Polynesian populations, and also the other populations. Negative F~ST~ values were set to 0 because F~ST~ is biologically bounded to [0,1]. Negative values occur when the variation within a population is larger than between populations.  



The ancestral allele was used as annotated in the 1000 Genomes Phase 3 \gls{vcf} file where possible, for use as the out-group population. A new sample identified as 'Ancestor' was included in the phased \gls{vcf}, and for each marker the genotype for this sample was set as the homozygote for either the reference or alternate allele, dependent on the ancestral allele matching, otherwise the Ancestor genotype was set to missing. When the phased \gls{vcf} files were loaded into PopGenome, populations were identified using panel files which were white-space delimited files with sample id, population, and super population as the columns. The out-group population for \gls{fwh} was set to be that of the Ancestor sample so that the ancestral allele would be used in the calculation.


#### SelectionTools {#selectionTools}

SelectionTools v1.1 [@Cadzow2014] was used to generate the haplotypic selection statistics of \gls{ihs}, \gls{nsl}, and \gls{xpehh}. The combined population phased \gls{vcf} file was split into individual populations. Within each population, markers were filtered for a \gls{maf} of > 0.01 and a \gls{hwe} exact test of P > 10^-6^ [@Wigginton2005]. Markers were converted into "ancestral" or "derived" by comparing alleles to the \textit{homo sapiens} ancestral fasta (see Table \@ref(tab:refDatasets)) with alleles that matched the ancestor set to 0, and non-missing, non-matching alleles set to 1.

\gls{ihs}, \gls{nsl}, and \gls{xpehh} normalisation with frequency bins of 0.05 was done using _norm_ as part of selscan v1.1.0b [@Szpiech2014]. Markers with an \gls{ihs}, \gls{nsl} or \gls{xpehh} value > |2.6| met the threshold for significance, which was equivalent to approximately 1% of the most extreme values.

Significant markers were also clustered into genomic regions using the DBSCAN package v1.1.1 [@dbscanref] in R, where nearby \glspl{snp} were assigned the same group identifier. The search radius used was 200 kb and the minimum number of points for a cluster was one. Cluster regions were created by taking both the minimum and maximum position for each group identifier, population, and chromosome.



### Disease associated gene lists {#diseaselist}

In order to create lists of genes that were associated with urate, gout, obesity, \gls{t2d}, metabolic syndrome, and kidney disease, disease trait entries were downloaded from the \gls{gwas} catalog^[gwas_catalog_v1.0.1-associations_e89_r2017-06-19.tsv https://www.ebi.ac.uk/gwas/ accessed 19 June 2017] [@MacArthur2017]. The file was a rectangular format, with rows for each study result, and columns such as reference paper, disease trait, association statistics, and mapped genes. Entries were then filtered for P < 5x10^-8^. From the filtered results, the kidney disease gene list was created by filtering the "disease trait" column to select rows with the keywords "kidney" or "renal". Entries were then removed that had the keywords "transplant", "carcinoma", "Type", "stones", "gout", "related", or "Diabetic kidney disease". For the gout, urate, obesity, \gls{t2d}, and metabolic syndrome gene lists the following keywords were used on the "disease trait" column to select rows of the P-value filtered data: "metabolic syndrome", "obesity", "diabetes", "urate", "gout", "body mass", and "lipid traits". This subset was then filtered to remove rows containing these keywords in the "disease trait" column: "child", "erectile", "lean", "autoantibodies", "gestational", "cancer", "psychopharmacol", "metaformin", "metformin", "obstructive", "interaction", "asthmatics", "omega", "pain", "cataracts", "time", "bilirubin", "chain", "thyroid", "zhi", "Type 1", or "cystic". From this filtered data, keywords were used to select rows relating to each trait of interest from the "disease trait" column. The keywords "urate" and "gout" were used for gout and urate, "obesity" and "body mass" used for obesity, "diabetes" used for \gls{t2d}, and "syndrome" used for metabolic syndrome. The keywords "kidney" and "renal" were used for kidney disease, with entries removed that had keywords of "transplant", "carcinoma","type", "stones","gout", "related", and "Diabetic kidney disease". 

Additional gene lists were created for malaria, auto-immune and auto-inflammatory diseases, and neurological diseases. The keyword "malaria" was used to filter the disease trait column to create the malaria gene list. The auto-immune and auto-inflammatory gene list was based on diseases that were listed in Table 2 of @Zhang2013a. The following keywords were filtered for in the disease trait column: "Crohn's disease", 'Celiac disease', "Ulcerative colitis", "Inflammatory bowel disease", "Type 1 diabetes", "Rheumatoid arthritis", "Multiple sclerosis", "Psoriasis", "Systemic lupus erythematosus", "Primary biliary cirrhosis", and "Vitiligo". Finally, a list of genes associated with neurological diseases was created by filtering the disease trait column for the keywords "Parkinson's disease" and "Alzheimer's disease". All keyword matching was case-insensitive. The code used for the creation of the gene lists is found in Appendix \@ref(gwascatlist). A list of the traits for each category can be found in Table \@ref(tab:gwascatref) and a list of the genes and what category they are from is in Table \@ref(tab:gwasgenes). 


```{r markdown2, eval = FALSE, include = FALSE}

### Selection database creation

It was decided that in order to store the results from the seletionTools pipeline in an efficient manner that a database should be used. This involved creating a database schema from scratch. The database schema was co-designed in consultation with Nick Burns and the initial loading scripts were created by Nick for use with MySQL (https://github.com/nickb-/SelectionDW_ETL). These initial scripts were further developed by myself and re-implemented them for use with PostgreSQL v9.6 (https://github.com/murraycadzow/SelectionDW_ETL). The functionality to load the inter-population statistics was also added later.

The schema of the database consists of 4 main data tables and 3 supplementary tables. The main data tables are comprised of intra-population selection statistics and inter-population statistics. The 3 supplementary tables provide annotation information to link a position id to a genomic position, link a statics id to the statistic name, and finally link a population id to a population name.

Custom Views were created to join the supplemental tables to the main tables.
```


### Principal component analysis {#pca}

\Glsdesc{pca} is a statistical dimension reduction technique that transforms potentially correlated variables into a linear and non-correlated set of variables. In a genetic context \gls{pca} is used to reduce variation at many thousands of markers into a handful of components that represent the majority of the variation of the data [@Patterson2006]. The components are ordered such that the first \gls{pc} captures the most variation, with each subsequent component capturing less. These components often, but not necessarily, represent population differences and population substructure.

\gls{pca} was used to identify the genetic ancestry of the samples from the Genetics of Gout in Aotearoa study to be used in the selection analysis (section \@ref(selectionDataset)). It was also used in the clustering analysis to identify the genetic groupings for the populations (section \@ref(pcaresults)). To calculate the principal components of the genetic data, all populations and chromosomes were combined into a single \gls{vcf} file with BCFtools v1.3.1, and then the independent markers were identified via Plink v1.9b4.9, using a sliding window to remove markers that had an inter-marker \gls{ld} R^2^ > 0.2, with windows of 50 kb and a slide of 5 markers. The first 10 principle components were calculated using smartPCA v13050 from Eigensoft v6.0.1 [@Price2006]. The following code was used to accomplish these steps.

```{r eigenstrat code, engine='bash', eval = FALSE}
#combine the chromosomes
bcftools concat \
  -O z \
  -o -o NZ_1KGP_allchr.vcf.gz \ 
  --threads 10 $(ls NZ_1KGP.chr*gz | sort -n -t'r' -k2)

#find the independent markers
plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
  --maf 0.1 \
  --indep-pairwise 50 5 0.2 \
  --out NZ_1KGP_allchr

# create an empty affection file that is required for Plink to use the --make-pheno
# which in turn is required for the creation of the ped file just the way
# SmartPCA wants it
touch cases.txt
plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
  --extract NZ_1KGP_allchr.prune.in \
  --recode \
  --out NZ_1KGP_allchr_indep \
  --make-pheno cases.txt '*'

# create the eigenstrat file
echo -e "genotype: NZ_1KGP_allchr_indep.ped\nsnpname: \
NZ_1KGP_allchr_indep.map\nindivname: \
NZ_1KGP_allchr_indep.ped\noutputformat: \
EIGENSTRAT\ngenotypeoutname: \
NZ_1KGP_allchr_indep.eigenstratgeno\nsnpoutname: \
NZ_1KGP_allchr_indep.snp\nindivoutname: \
NZ_1KGP_allchr_indep.ind\nfamilynames: \
NO" > par.PED.EIGENSTRAT

# calculate the principle components
convertf -p par.PED.EIGENSTRAT > eigen.log
smartpca.perl \
  -i NZ_1KGP_allchr_indep.eigenstratgeno \
  -a NZ_1KGP_allchr_indep.snp \
  -b NZ_1KGP_allchr_indep.ind \
  -o NZ_1KGP_allchr_indep_eigen.pca \
  -p NZ_1KGP_allchr_indep_eigen \
  -e NZ_1KGP_allchr_indep_eigen.eval \
  -l NZ_1KGP_allchr_indep_eigen.log \
  -m 0
```

### Admixture analysis {#admixture}

Admixture arises when two populations that were previously separate, begin to interbreed, changing the allele frequencies in the new population [@Pritchard2000]. Genetic admixture analysis estimates the proportions and the variant frequencies of the ancestral populations that contributed to the admixture. This is often done to account for population structure in \gls{gwas} studies. Admixture analysis was performed to estimate the number of ancestral populations that that contributed to the populations used in the selection analysis. It was also used because the Polynesian populations have varying degrees of admixture [@Wollstein2010].

Admixture analysis was performed using ADMIXTURE v1.3.0 [@Alexander2009]. \Gls{vcf} files for all autosomes were concatenated and the independent markers were selected by a moving window of 50 kbp sliding by 10 markers and removing markers with a marker \gls{ld} R^2^ > 0.1. This was done using Plink v1.9b4.9. Following this, cross validation was performed to find the best value of K (number of ancestral populations), for values of K from 1 to 15. The default of 5-fold cross-validation was used, whereby the data were partitioned into five groups, with four used to train the model, and the fifth to test the model. This was repeated five times, using a different combination of the partitions each iteration. The following code was used to calculate the cross-validation errors.

```{r admixture k, engine = 'bash', eval = FALSE}
# Combine the chromosomes
bcftools concat \
  -O z \
  -o NZ_1KGP_allchr.vcf.gz \
  --threads 10 $(ls NZ_1KGP.chr*gz | sort -n -t'r' -k2)

# find the independent snps
plink1.9b4.9 \
  --vcf NZ_1KGP_allchr.vcf.gz \
  --indep-pairwise 50 10 0.1 \
  --out NZ_1KGP_allchr_admix

# extract the independent snps
plink1.9b4.9 \
  --vcf NZ_1KGP_allchr.vcf.gz \
  --make-bed --extract NZ_1KGP_allchr_admix.prune.in \
  --out NZ_1KGP_allchr_admix

# do the cross-validation for the admixture components for K 1-15 
for K in $(seq 1 15)
do 
  admixture -s 123456 --cv NZ_1KGP_allchr_admix.bed $K -j20 | tee log${K}.out
done

grep CV log* | cut -d':' -f1,3 |tr -d ':' | sed 's/log\|\.out//g' > CV_error.txt
```



<!-- Admixture ancestry proportions were also calculated using only the populations of \gls{afr}, \gls{eas}, \gls{eur}, and \gls{sas} and cross-validation error calculated for values of K from 1 to 15. The default of 5-fold cross-validation was used. The following code was used to calculate the cross-validation errors and then project the admixture components for the K with the lowest cross-validation error onto the \gls{pol} and \gls{amr} populations. -->

```{bash, eval = FALSE, echo = FALSE}
# to project 1000 genomes onto the Polynesians

#create reference population
#remove AMR and POL (and NZC) pops
cat nz_1kgp.panel |\
grep -v 'POL\|AMR\|NZC' |\
awk '{if(NR > 1){print $1,$1}}' > 1kg_ref.list

# create the reference population
plink1.9b4.9 --bfile NZ_1KGP_allchr_admix \
  --make-bed \
  --keep 1kg_ref.list \
  --out reference \
  --keep-allele-order

# create 'study population'
cat nz_1kgp.panel |\
grep 'AMR\|NZC\|CIM\|TON\|NZM\|SAM' |\
awk '{if(NR > 1){print $1,$1}}' > pol_amr_nzc.list

plink1.9b4.9 --bfile NZ_1KGP_allchr_admix \
  --make-bed \
  --keep pol_amr_nzc.list \
  --out study \
  --keep-allele-order

# check bim files are identical
diff -s reference.bim study.bim

# select best K from CV testing
parallel '
  admixture -s 123456 \
  --cv reference.bed {} -j10 | tee log{}.out '\
::: $(seq 1 15)

# K = 9 as best
admixture -s 123456 -B reference.bed 9
# create study input P
cp reference.9.P study.9.P.in

# project the components onto the AMR and POL populations
admixture -s 123456 -P study.bed 9
```


<!-- ### GWAS -->

<!-- UK Biobank GWAS -->




### Heritability analysis {#gctaHeritability}

Heritability analysis is a method for determining what proportion of phenotypic variation can be attributed to environmental effects (non-heritable) and genetic effects (heritable) [@Visscher2008]. There are two measures of heritability, the first is known as broad-sense heritability (H^2^) and is the ratio of the total genetic variance to the total phenotypic variance. The second measure is narrow-sense heritability (h^2^) and is the ratio of the genetic variance attributed to an additive genetic model to the total genetic variance.

The \gls{gcta} v1.26.0 software [@Yang2011] was used to calculate the proportion of genetic heritability explained for gout. First the UK Biobank genetic data (section \@ref(ukbbdata)) were subsetted to only contain gout cases and controls and the genome partitioned into chromosomes. A \gls{grm} was created for each chromosome. The genetic variance explained was calculated for each chromosome using restricted maximum likelihood analysis and a general population prevalence for gout of 2%. The following code was used to calculate the \gls{grm} and partition the genetic heritability by chromosome.


```{r, engine='bash', eval=FALSE}

# load fam into R
# sample(10000, fam[AFF == controls]) -> controls.txt
# cat condition.fam | 
# awk '{if($6 == 2){print $1"\t"$2}}' | cat - controls.txt > ids_keep.txt

# Subset samples
for i in $(seq 1 22)
do 
  plink2 --bed $ukbio_path/chr${i}impv1.bed \
            --bim $ubkbio_path/chr${i}impv1.bim_1kg_marker \
            --fam $ukbio_path/chrallimpv1.fam_allgout_allcontrols \
            --hwe 0.000001 \
            --maf 0.01 \
            --keep ids_keep.txt \
            --make-bed \
            --out gout_chr${i} \
done


# Calculate the genetic relationship matrix by chromosome
for i in $(seq 1 22)
do 
  gcta1.26.0 \
    --bfile gout_chr${i} \
    --chr ${i} \
    --make-grm-bin \
    --out ukbio_10ksample_grm_chr${i} \
    --thread-num 16 > grm_${i}.log  \
done

# Calculate the genetic variance explained using a 
# general population gout prevalence of 2%
for i in $(seq 1 22) 
do 
  gcta1.26.0 \
    --grm ukbio_10ksample_grm_chr${i} \
    --pheno phenos.txt  \
    --prevalence 0.02 \
    --out var_chr${i} \
    --reml \
    --chr ${i} \
    --thread-num 16 \
done
```



<!-- ### Variant Annotation -->

<!-- Variant annotation of \gls{vcf} files was performed using snpEff v4.2 [@snpeff] with the homo sapiens GRCh37 database. -->


### Pathway Analysis


<!-- Panther http://pantherdb.org -->

<!-- version 13.0 (released 2017-11-12) -->

<!-- for population lists used the "Functional classification viewed as pie chart" selected biological process and exported the results as a table -->

<!-- Analysis Type: PANTHER Overrepresentation Test (release 20170413) -->
<!-- - annotation set = pnather GO-slim biological process -->

Gene set analysis was performed by inputting gene lists into Enrichr^[http://amp.pharm.mssm.edu/Enrichr/] [@Chen2013b; @Kuleshov2016]. The pathway enrichment results were based on the \gls{kegg} 2016 table, which is a long-standing database, curated by a small group of experts [@Kanehisa2017]. A significance threshold for a pathway was set at P < 0.05 after Benjamini-Hochberg adjustment [@Benjamini1995] for multiple hypothesis testing, as provided by Enrichr.

<!-- The p-value is computed from the Fisher exact test which is a proportion test that assumes a binomial distribution and independence for probability of any gene belonging to any set -->

<!-- adjusted p-value: or q-value is an adjusted p-value using the Benjamini-Hochberg method for correction for multiple hypotheses testing -->

<!-- z-score: the rank based ranking is derived from running the Fisher exact test for many random gene sets in order to compute a mean rank and standard deviation from the expected rank for each term in the gene-set library and finally calculating a z-score to assess the deviation from the expected rank -->

<!-- combined score is computed by taking the log of the p-value from the Fisher exact test and multiplying that by the z-score of the deviation from the expected rank (c = log(p) * z) -->


## Datasets {#datasets}

The following sections describe the genomic datasets used in this thesis.

### 1000 Genomes Project Phase 3 {#1kgpdesc}

<!--
@misc{1kgp_ftp,
keywords = {1KGP},
mendeley-groups = {PPARGC1Apaper,Datasets},
mendeley-tags = {1KGP},
title = {{1000 Genomes Project FTP}},
url = {ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/},
urldate = {2015-08-18}
}
-->

The \glsdesc{1kgp} was an international consortium that was established in 2007 to provide a comprehensive record of human genetic variation [@siva2008]. The project consisted of three main data phases. A pilot phase that whole-genome sequenced 179 individuals from four populations at low coverage (2-4x), along with high coverage sequencing for two trios (mother, father, and child), and exon targeted sequencing for 697 individuals from seven populations [@1KGP2010]. The second main data phase provided sequencing data for 1092 individuals from 14 populations. This sequencing data set was a combination of low coverage whole-genome and exon sequencing [@1KGP2012]. The third main phase (Phase 3) was a dataset consisting of low coverage whole-genome sequencing, deep exome sequencing, and dense \gls{snp} array genotyping for 2504 individuals from 26 populations [@1KGP2015snp]. The 1000 Genomes data set used in this thesis was the Phase 3 release^[ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ accessed 20 March 2017].


```{r populations, results = 'asis', echo = FALSE}

read.csv('data/02-populations.csv', stringsAsFactors = FALSE) %>% left_join(., panel %>% group_by(pop) %>% tally(), by = 'pop') %>% filter(!pop %in% c("EPN","OMN","AXI","WPN","NAD") & superPop != "") %>% arrange(superPop, pop) %>% mutate(pop = if_else(pop %in% c("NZM","NZC","CIM","SAM","TON"), paste0(pop,'*'), pop))%>% select("Population" = pop, "Description" = description, n, "Genotype\nPlatform" = genotypePlatform) %>%  knitr::kable(format = 'latex', booktabs = TRUE, caption = '(\\#tab:populations) Description of Populations used in the selection analysis (n = 3004).') %>% kableExtra::group_rows("African Super Population (AFR) n = 661", 1,7) %>% kableExtra::group_rows("Admixed American Super Population (AMR) n = 347", 8, 11) %>% kableExtra::group_rows("East Asian Super Population (EAS) n = 504", 12, 16) %>% kableExtra::group_rows("European Super Population (EUR) n = 603", 17, 22) %>% kableExtra::group_rows("Polynesian Super Population (POL)* n = 400", 23, 26) %>% kableExtra::group_rows("South Asian Super Population (SAS) n = 489", 27, 31) %>% kableExtra::add_footnote("NZC, NZM, TON, SAM, and CIM are from the 'Genetics of Aotearoa' study. All others are from the 1000 Genomes Project.", notation = "symbol") %>% kableExtra::kable_styling(font_size = 8)
```


### Genetics of Gout in Aotearoa study

The genetics of Gout in Aotearoa study is a case-control cohort for gout, with recruitment mainly from the Auckland, Wellington, Christchurch and Dunedin regions of New Zealand. Participants were asked to fill in a questionnaire regarding demographic information, clinical information, and gout-relevant food consumption at the time of recruitment. Gout cases fulfilled the \gls{acr} criteria [@Wallace1977a]. Controls self-reported no history of gout at the time of recruitment. All individuals gave written informed consent, and ethical approval was obtained from the New Zealand multi-region ethics committee (MEC/105/10/130). Individuals from this study were genotyped on Illumina CoreExome v24 \gls{snp} arrays using DNA extracted from blood samples provided at the time of recruitment. Table \@ref(tab:clinInfoCE) provides the overall clinical characteristics for this cohort.

A subset of the individuals from this study were used to form four populations of Polynesian ancestry, two for East Polynesia (\gls{cim} and \gls{nzm}), and two for West Polynesia (\gls{sam} and \gls{ton}), and one population of European ancestry (\gls{nzc}). These sub-populations formed part of the selection analysis dataset described in section \@ref(selectionDataset)). 

```{r, eval = FALSE, echo = FALSE, include = FALSE}
<!--
whole genome low-coverage resequenced, or exome resequence data.
#### Axiom

- about
- population

| | obs missing (n) | Maori AXIOM
---|---|---
Number | - | 71 
Sex (% male) | - | 64.7
Gout cases (%) | - | 49.3
Mean BMI (range) | 1 | 34.5 (22.1 to 56.1)
Diabetes (%) | 3 | 21.1
Mean grandparent ancestry (range) | - | 0.916 (0.625 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- markers
- density


#### Omni


| | obs missing (n) | Samoan OMNIexpress
---|---|---
Number | - | 96
Sex (% male) | - | 74
Gout cases (%) | - | 50.0
Mean BMI (range) | - | 36.1 (20.5 to 93.4)
Diabetes (%) | - | 12.5
Mean grandparent ancestry (range) | - | 0.997 (0.875 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- about
- population
- markers
- density
-->
```
#### CoreExome {#coreExomeQC}


The Infinium CoreExome-24 bead-chip is a genotyping platform available from Illumina and is comprised of a core set of 551,839 markers. A subset of the individuals in the Genetics of Gout in Aotearoa study were genotyped on this platform at the University of Queensland (Centre for Clinical Genomics). Genotype quality control was performed by Dr Tanya Major (Merriman Lab) following the protocol from @Guo2014 and the Illumina GenomeStudio best practice guidelines^[https://www.illumina.com/Documents/products/technotes/technote_infinium_genotyping_data_analysis.pdf accessed 18 January 2016]. Illumina’s GenomeStudio v2011.1 genotyping module v1.9.4 was used for the initial calling of genotypes. Samples were exported from GenomeStudio that had a call rate > 98%, markers were removed if the call-rate was < 95%. Individuals who had not reported their sex were assigned their genetic sex where possible. Individuals were removed where genetic and reported sex did not match. The cohort was checked for genotype consistency between duplicated markers, with duplicates subsequently removed. 
<!-- Samples were also checked for outliers in heterozygosity and depression of genetic variation. -->

Markers were subsetted to only include bi-allelic \glspl{snp}, with a final marker number of `r NROW(markers)` and density of `r lapply(1:22, function(x){diff(markers %>% filter(chrom ==x) %>% arrange(chrom_start) %>% pull(chrom_start))}) %>% unlist() %>% mean() %>% round_dp(., 0)` bp/marker. Relatedness between individuals was assessed through inheritance by state using Plink v1.9b3.32 and a pedigree of families created by Dr Tanya Major (Merriman lab) to identify family groups. Duplicates and first degree relations were excluded and single individuals were randomly selected from family groups identified through identity by state analysis, which determined the proportions of individual genomes that were identical in a pair-wise manner. 
In order to account for population specific genetic differences, self-report of grandparent ethnicity was used to infer the genetic ancestral populations from clusters of individuals after plotting different \glspl{pc} from the \gls{pca} on the genetic markers (section \@ref(pca)). Individuals were removed from further analysis where there was disagreement between self-reported grandparent ethnicity and the inferred genetic ancestry. \Glsdesc{hwe} of markers was checked for European, East Polynesian, and West Polynesian populations using a \gls{hwe} exact test [@Wigginton2005] in Plink v1.9b3.32, and variants were removed if they had a Bonferroni multiple testing corrected P < 0.05.




```{r, include = FALSE, eval = FALSE}
Marker Categories | Number of Markers
---|---
In RefSeq Genes | 374,258 (399,009 within 10 kb)
In RefSeq Exons | 269,186
In RefSeq Promoter Regions | 13,990
In ADME Genes | 11,276 (12,455 within 10 kb)
In ADME Exons | 9,314
MHC (Extended MHC) | 3,940 (5,628)
Overlap with Genes in COSMIC | 365,135
Overlap with Genes in Gene Ontology | 96,331
Nonsense Markers | 14,994
Missense Markers | 219,162
Synonymous Markers | 14,747
Silent Markers | 8,850
Mitochondrial Markers |351
Indels | 12,436

mean call rate
mean missing
number of snps passing qc
number of snps used for selection


(http://www.illumina.com/content/dam/illumina-marketing/documents/products/datasheets/datasheet_human_core_exome_beadchip.pdf, accessed 16 Jan 2017)
```


```{r, echo = FALSE, eval = FALSE}
marker_loc <- readRDS('~/data/NZ_coreExome_1kgp/snpEff_Annotated/snpeff_terms.RDS') %>% select(chrom = V1, pos = V2, snp = V3, ref = V4, alt = V5, eff )


left_join(markers, marker_loc, by = c("chrom" = "chrom", "chrom_start" = "pos", "marker" = "snp", "ref","alt")) %>% arrange(chrom, chrom_start) %>% group_by(eff) %>% tally() %>% rename("Effect Annotation" = eff)%>% kable(caption = "(\\#tab:CEmarkerTypes) Number of each type of marker annotation from snpEff v4.2 of the CoreExome markers used for the selection analysis.")
#subsetByOverlaps(marker_loc %>% mutate(start = pos, end = pos+1)%>% GRanges(),create_sums('td_neg') %>% filter(POLsum == ALLsum) %>% select(1:3) %>% GRanges()) %>% data.frame() %>% group_by(eff) %>% tally()

```

<!-- ### Polynesian Gout \gls{gwas} dataset -->

<!-- > will be inserted once it is finalised -->

```{r, warning= FALSE, message = FALSE, echo = FALSE}
ce_clinical_table() %>% kable(., col.names = c("", rep(c("Control","Gout"), 3)), booktabs = TRUE, format = 'latex', caption = ' (\\#tab:clinInfoCE) Clinical information for samples that were genotyped on the CoreExome platform by genetic ancestry.', align = 'lrrrrrr') %>% add_header_above(., c("", "European" = 2, "Eastern Polynesian"= 2, "Western Polynesian" = 2)) %>% kable_styling(latex_options = 'scale_down')
```



```{r, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE}
ce_pop_table <- ce_populations_table()
#names(ce_pop_table) <- c("pop","n","Age","Sex (% Male)","BMI","Waist","Percent Diabetes","Percent Gout")

```





### Selection dataset {#selectionDataset}

#### Sample selection

A subset of the individuals were chosen to create representative sample Polynesian populations of similar size to the other populations in the \gls{1kgp} to be used in a comparison for the selection analyses. \Glsentrydescplural{pc} were calculated for all individuals genotyped on the CoreExome \gls{snp} array using SmartPCA (EIGENSOFT v6.0.1, see section \@ref(pca)) using 2858 ancestry informative markers (@Guo2014 supplementary material). The first 10 eigenvectors were outputted, with no outlier removal or population size limit. Individuals were removed who did not match between self reported ethnicity of grandparents and their genetic ancestry, or if they had self reported all grandparent ethnicities as unknown.

\Glsdesc{pc} 2 was identified as providing the best separation of European ancestry from Polynesian ancestry, and \gls{pc} 4 had the best separation of East Polynesian from West Polynesian ancestry. Individuals were then filtered for European or Polynesian ancestry. Individuals reporting 4 grandparents of European, New Zealand M\tex{\={a}}ori, Cook Island M\tex{\={a}}ori, Samoan, and Tongan ancestry were used to define the threshold values, as they were most likely to represent the ancestral populations. The mean and SD for \gls{pc} 2 and \gls{pc} 4 were calculated for the individuals who had self reported four grandparents of the same ethnicity. Thresholds were then applied using the four grandparent population mean $\pm$ 2 SD for \gls{pc} 2 and \gls{pc} 4 for each corresponding self-report population group. Samples were filtered so that only those that lay within the thresholds remained. Population samples of 100 individuals were created by using genetic ancestry for the following populations: \glsdesc{nzm}, \glsdesc{cim}, \glsdesc{sam}, \glsdesc{ton}, and \glsdesc{nzc}, by randomly sampling from within each ancestry group (Figure \@ref(fig:cePCA)). To create a population sample that resembled the general population for gout prevalence, individuals were prioritised based on gout affection to reach population specific prevalences based on @Winnard2013 of 2.3% for \gls{nzc}, 7.7% for \gls{nzm}, and 8.6% for \gls{cim}, \gls{sam}, and \gls{ton}. Final sample population prevalence of 2.0% (\gls{nzc}), 7.0% (\gls{nzm}), 45.0% (\gls{cim}), 12.0% (\gls{sam}), and 54.0% (\gls{ton}) were obtained for gout (Table \@ref(tab:cePopTable)).


```{r,echo = FALSE}
knitr::kable(data.frame(ce_pop_table), caption = '(\\#tab:cePopTable) Clinical information for New Zealand Populations used in the selection analysis',align = 'lcrrrrrrrr', col.names = c("Population","n","Mean Age yrs (SD)","Sex (\\% Male)","Mean BMI kg/m\\textsuperscript{2} (SD)","Mean Waist cm (SD)","Diabetes (\\%)","Gout (\\%)", "Kidney Disease (\\%)","Heart Problems (\\%)"), booktabs = TRUE, format = 'latex', escape = FALSE ) %>% column_spec(column = c(3:10), width = '3.5em') %>% kable_styling(latex_options = 'scale_down')
```
 

(ref:cePCA) Principal components 2 and 4 for individuals used in the selection analysis.

```{r cePCA, fig.cap = '(ref:cePCA)', echo = FALSE, out.width = "70%",fig.align="center"}
knitr::include_graphics('images/02_methods/pca_plot.png')
```



#### Filter individuals and markers 

To create a data set from which to calculate selection statistics, the subset of the Genetics of Aotearoa individuals genotyped on the Illumina CoreExome chip were combined with all of the individuals in the \gls{1kgp} phase 3 release. This was done in order to have a common set of markers between all populations, making the populations comparable. Before the data sets could be combined there were a series of steps that were performed. The first step (code following) was to keep only the individuals who had been selected through \gls{pca} and had a genotyping rate (percentage of all markers with genotypes) of at least 95%. Due to software requirements, markers were filtered to remove \glspl{indel} so that only \glspl{snp} remained.

```{r, engine = 'bash', eval = FALSE}
parallel '
  plink2 \
    --bfile src_data/QC1_7-plus_correctAff \
    --recode vcf \
    --out QC1_7-plus_correctAff.chr{} \
    --chr {} \
    --remove src_data/QC1_7-BlanketExclusions.txt \
    --keep coreExome_selection_keep_ids.txt \
    --allow-no-sex \
    --snps-only no-DI \
    --geno 0.95
    ' ::: $(seq 1 22)
```

The second step was to ensure that all the CoreExome markers were normalised against the hs37d5 human reference. This was to make sure the reference (REF) and alternative (ALT) alleles would match with the \gls{1kgp} phase 3 for a successful merge after phasing and subject selection. SHAPEIT2 was then used to find \gls{snp} alleles that disagreed with the \gls{1kgp} haplotype reference and phase the CoreExome markers. This step (code following) also reduced markers to bi-allelic positions and removed duplicate positions.

```{r, engine = 'bash', eval = FALSE}
parallel '
  bcftools norm \
    -N \
    --rm-dup any \
    --check-ref s \
    -f hs37d5.fa \
    -O v QC1_7-plus_correctAff.chr{}.vcf | \
  bcftools view \
    -m 2 \
    -M 2  \
    -O z \
    -o QC1_7-plus_correctAff_norm.chr{}.vcf.gz \
  ' ::: $(seq 1 22)

```

After normalisation, the \gls{vcf} files were phased using the 1000 Genomes Project phase 3 reference haplotypes as described in section \@ref(phase).

#### Merge genotypes

In order to efficiently merge the data sets, the intersection of the markers from the \gls{1kgp} dataset and the CoreExome dataset was found. This was done by extracting the marker positions and alleles from the CoreExome data and then matching these to the marker positions extracted from the \gls{1kgp} phase 3. The \gls{1kgp} phase 3 markers were also filtered to remove non bi-allelic \glspl{snp}. The following code demonstrates these steps.

```{r, engine = 'bash', eval = FALSE}
# extract markers from core exome
parallel '
  zgrep \
    -v "^#" QC1_7-plus_correctAff_norm.chr{}.phased.vcf.gz |\
    cut -f1,2,4,5 > coreExome_chr{}_biallelic_markers.txt 
    ' ::: $(seq 1 22)

# extract 1000 Genomes markers
parallel '
  bcftools view \
    -O v \
    -m 2 \
    -M 2 \
    -v snps \
    -o - \
    ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz |\
  grep -v "^#" |\
  cut -f 1,2,4,5 > 1kgp_chr{}_biallelic_markers.txt 
  ' ::: $(seq 1 22)
```


An R script (below) was created in order to merge the two marker lists based on chromosome position and the reference and alternate alleles. 

```{r, eval=FALSE}
# create list of markers present in CoreExome data
ce_markers <- data.frame()
tmp_list <- list()
for(i in 1:22){
  tmp_list[[i]] <- read.table(file = paste0(
    'NZ_coreExome/coreExome_chr',
    i,'_biallelic_markers.txt'), header=FALSE)
}
ce_markers <- do.call(rbind, tmp_list)

# create list of markers present in 1KGP data
kg_markers <- data.frame()
tmp_list2 <- list()
for(i in 1:22){
  tmp_list2[[i]] <- read.table(file= paste0(
    '1kgp_chr',i,'_biallelic_markers.txt'), 
    header=FALSE)
  # find the markers in common between CoreExome and 1KGP
  tmp_list2[[i]] <-  tmp_list2[[i]][ tmp_list2[[i]][,2] %in% tmp_list[[i]][,2],]
}
kg_markers <- do.call(rbind, tmp_list2)
ce_kg <- merge(ce_markers, kg_markers, by = c("V1","V2","V3","V4"))

# write out the common markers
write.table(file = 'ce_1kg_matched_markers.txt', ce_kg[,c(1,2)], 
            row.names = FALSE, col.names=FALSE, quote=FALSE)
```

Once the combined marker list was created, both the CoreExome and \gls{1kgp} data sets had their markers filtered to this consensus set. The code for marker filtering of the \gls{vcf} files and subsequent merge is shown below.
```{r, engine = 'bash', eval = FALSE}
# filter 1000 Genomes markers
parallel '
  bcftools view 
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.matched.vcf.gz \
    ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz 
  ' ::: $(seq 1 22)

# filter coreExome markers
parallel '
  bcftools view \
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o NZ_coreExome.chr{}.norm.phased.matched.vcf.gz \
    QC1_7-plus_correctAff_norm.chr{}.phased.vcf.gz 
  ' ::: $(seq 1 22)

# merge 1kgp and nz coreexome
parallel 
  'bcftools merge \
    -O z \
    -o NZ_1KGP.chr{}.phased.vcf.gz \
    ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.matched.vcf.gz \
    NZ_coreExome/NZ_coreExome.chr{}.norm.phased.matched.vcf.gz 
  ' ::: $(seq 1 22)
```

Sample identifiers were then updated to match the panel file that described the population and super population an individual belonged to. The  following code applies this step to each merged \gls{vcf} file.
```{r, engine = 'bash', eval = FALSE}
# Combine FID and IID of CoreExome samples so they match the panel file
for i in $(seq 1 22)
do 
  zcat NZ_1KGP.chr$i.phased.vcf.gz |\
  head -1000 |\
  grep '^#CHROM' |\
  cut -f10- |\
  tr '\t' '\n' |\
  awk -F "_" '{if(NF ==1 ) {print $1 "\t" $1}else{print $1"_"$2"\t" $2}}' |\
  bcftools reheader \
    -s /dev/stdin/ \
    -o NZ_1KGP.chr$i.phased.sample_updated.vcf.gz \
    NZ_1KGP.chr$i.phased.vcf.gz
done
```



### UK Biobank {#ukbbdata}

The UK Biobank is a collection of 500,000 individuals, mostly of European ancestry, from around the United Kingdom, aged between 40 and 69. It consists of genetic, health, and lifestyle information. The interim release dataset (approval number 12611) was downloaded in November 2015 and contained genotypes for 152,249 individuals. Gout affection was determined by self-report, or self-reported use of urate lowering therapy, or an International Classification of Diseases, Tenth Revision (ICD-10) code for gout (M10, including sub-codes). The dataset was also filtered to individuals with a self reported ethnic background of British, Irish, or 'any other white background'. Individuals were removed who had a mismatch between self-reported sex and genetic sex, or whose samples failed genotype quality control. The remaining individuals were eligible for inclusion in the \gls{gwas} performed in section \@ref(ukbbgwas).



### Reference datasets

Table \@ref(tab:refDatasets) provides the name of the dataset, the date it was accessed, and the URL from which the dataset was downloaded. These datasets were incorporated into many of the analysis steps.

Table: (\#tab:refDatasets) _Reference Datasets_

| Name | Date | URL |
|:-------------------------------|--------------------------|--------------------------------------------------------------|
|1000 Genomes Project Phase 3 release 5 |20 Mar 2017| http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ |
|1000 Genomes Phase 3 phased haplotypes |14 Dec 2014| https://mathgen.stats.ox.ac.uk/impute/1000GP_Phase3.html |
|Human Genome Reference FASTA | 5 Aug 2014 | ftp://ftp.1000genomes.ebi.ac.uk:21/vol1/ftp/technical/reference/phase2_reference_assembly_sequence/hs37d5.fa.gz |
|Human Ancestral Allele FASTA | 6 Aug 2014 | ftp://ftp.ensembl.org/pub/release-66/fasta/ancestral_alleles/homo_sapiens_ancestor_GRCh37_e66.tar.bz |


