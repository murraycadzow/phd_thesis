# Methods/Data
```{r, echo = FALSE, message = FALSE, warning= FALSE}
library(tidyverse)
library(pander)
library(kableExtra)
library(phdFunctions)
source("scripts/methods_tables.R")
panel <- read.table('~/data/NZ_coreExome_1kgp/nz_1kgp.panel', header = TRUE, stringsAsFactors = FALSE)
markers <- read.table('~/data/NZ_coreExome_1kgp/nz_1kg_markers.txt', stringsAsFactors = FALSE, header = FALSE)
names(markers) <- c("chrom","chrom_start","marker","ref","alt")
```

```{r, echo = FALSE, inlcude = FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

```{r, linewidth=80, tidy=TRUE, include = FALSE, eval=FALSE}
# this is an example of how linewidth will cut the output short, however it doesn't wrap the code chunk
a <- '## "stx2A; shiga-like toxin II A subunit encoded by bacteriophage BP-933W; K11006 shiga toxin subunit A" '
a
```

## Methods

Unless otherwise specified all genomic resources and co-ordinates reported in this project use the human genome reference build GRCh37.

### Phasing {#phase}


Phasing was performed using SHAPEIT2 v2.r837 [@Delaneau2013] using the \gls{1kgp} haplotype panel. There were two steps involved for phasing of genotypes. The first was to check the markers were aligned with the markers in the reference haplotypes. This was done using the SHAPEIT2 -check flag.

```{bash, eval = FALSE, echo =TRUE}
# Check alignment of markers against reference haplotypes
# ? = chromosome
shapeit2 \
-check \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
  --output-log coreExome_norm.chr?.checked \
  -T 12
```

The second step was the actual phasing step. 


```{bash, eval = FALSE, echo = TRUE}
# Run phasing against reference haplotypes
# Exclude misaligned markers
# Use 8 threads
# ? = chromosome
shapeit2 \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
--output-max coreExome_norm.chr?.phased \
--exclude-snp coreExome_norm.chr?.checked.snp.strand.exclude \
-T 8


# Convert haps to vcf.gz
shapeit2 \
-convert \
--input-haps coreExome_norm.chr?.phased \
--output-vcf coreExome_norm.chr?.phased.vcf 
```




### Selection Statistics

#### PopGenome {#popgenomeMethods}

The PopGenome package (v2.2.3, @Pfeifer2014) for R was used for the calculation of \gls{td}, \gls{fwh}, \gls{fld}, \gls{flf}, \gls{ze}. The selection and neutrality statistics were calculated using a sliding window approach with a window size of 100 kb and a slide of 10 kb. Windows that had fewer than 4 segregating sites were filtered out and window co-ordinates were altered to be +/- 5 kb from the centre of the window. The empirical distribution for each population was used to create a significance threshold. The lower threshold was the 1st percentile and less than zero. The upper significance threshold was the 99th percentile and greater than zero. The greater or less than zero condition was to enable the interpretation of the selection and neutrality statistic results. F~ST~ was also calculated in the same sliding window set-up and pair-wise for between the Polynesian populations, and also the other populations. F~ST~ values that were negative were set to 0.

The ancestral allele was used as had been annotated from the 1000 Genomes Phase 3 \gls{vcf} file where possible for use as the out-group population. A new sample identified as 'Ancestor' was included in the phased \gls{vcf} and for each marker the genotype for this sample was set as the homozygote for either the reference or alternate allele dependent on the ancestral allele matching, otherwise the Ancestor genotype was set to missing. When the phased \gls{vcf} files were loaded into PopGenome, populations were identified using panel files which were white-space delimited files with sample id, population, and super population as the columns. The out-group population was set to be that of the Ancestor sample.


#### SelectionTools {#selectionTools}

SelectionTools v1.1 [@Cadzow2014] was used to generate the haplotypic selection statistics of \gls{ihs}, \gls{nsl}, and \gls{xpehh}. The combined population phased \gls{vcf} file was split into individual populations. Each population was filtered for a \gls{maf} of > 0.01 and a \gls{hwe} exact test of _p_ < 10^-6^. Markers were converted into ancestral or derived by comparing alleles to the homo sapiens ancestral fasta (see Table \@ref(tab:refDatasets)) with alleles that matched the ancestor set to 0, and non-missing, non-matching alleles set to 1.

\gls{ihs}, \gls{nsl}, and \gls{xpehh} normalisation with frequency bins of 0.05 was done using _norm_ as part of selscan v1.1.0b [@Szpiech2014]. Markers with an \gls{ihs}, \gls{nsl} or \gls{xpehh} value > |2.6| were determined to be significant, which was approximately the most extreme 1% of values.

Significant markers were also clustered into genomic regions using the DBSCAN package v1.1.1 [@dbscanref] in R, where nearby \gls{snp}s were assigned the same group identifier. The search radius used was 200 kb and the minimum number of points for a cluster was one. Cluster regions were created by taking both the minimum and maximum position for each group identifier, population and chromosome.



```{r markdown1, eval = FALSE, include = FALSE}
Table: (\#tab:seltoolStats) 


| Statistic | Program | Window Size | Reference |
|:----------------|:------------:|:-------------:|:---------------|
| _Window based_ | | | |
| Tajima's D | Vcftools | 30 kb | @Tajima1989|
| Fay and Wu's H | Variscan | 30 kb | @fay2000hitchhiking|
| Fu and Li's D | Variscan | 30 kb | @Fu1993|
| Fu and Li's F | Variscan | 30 kb | @Fu1993|
| $\eta$ (total number of mutations) |Variscan| 30 kb | |
| $\eta$~E~ (number of external mutations) |Variscan| 30 kb | |
| $\pi$ |Variscan| 30 kb | |
| S |Variscan| 30 kb | |
| mean F~ST~ | Vcftools| | |
| _Haplotype Based_ | | | |
| sL by allele | Selscan | | |
| sL1 | Selscan | | |
| unstandardised nSL |Selscan | | |
| standardised nSL |Selscan | | |
| ihh by allele | Selscan | | |
| unstandardised iHS | Selscan | | |
| standardised iHS | Selscan norm | | |
| iHH by population 1 | Selscan | | |
| iHH population 2 | Selscan | | |
| unstandardised XP-EHH | Selcan | | |
| standardised XP-EHH | Selscan norm | | |
| _Frequency_ | | | |
| Minor allele frequency | | | |
| Derived allele frequency | | | |

<!--
- Tajima's D (Vcftools) [@Tajima1989]|
- Fay and Wu's H  (Variscan) [@fay2000hitchhiking]|
- Fu and Li's D | Variscan  [@Fu1993]|
- Fu and Li's F | Variscan | 30 kb | [@Fu1993]|
- Eta (variscan) total (minimum number) number of mutations ($\eta$) 
- Eta E (variscan) number of external mutations ie number of derived singletons
- Pi (variscan) nucleotide diversity ($\pi$)
- S (variscan) number of segregating sites
- mean F~ST~ Vcftools

Haplotype based

- 



Gene
- Ka/Ks
-->
```
  
  
### Disease Gene Lists {#diseaselist}

Lists were filtered for P <  5x10^-8^. From the filtered results the kidney disease gene list was created by filtering the "disease trait" column to select rows with the keywords "kidney" or "renal". Rows were then removed that had the keywords "transplant", "carcinoma", "Type", "stones", "gout", "related", or "Diabetic kidney disease". For the gout, urate, obesity, \gls{t2d}, and metabolic syndrome gene lists the following keywords were used on the "disease trait" column to select rows of the P-value filtered data: "metabolic syndrome", "obesity", "diabetes", "urate", "gout", "body mass", and "lipid traits". This subset was then filtered to remove rows containing these keywords in the "disease trait" column: "child", "erectile", "lean", "autoantibodies", "gestational", "cancer", "psychopharmacol", "metaformin", "metformin", "obstructive", "interaction", "asthmatics", "omega", "pain", "cataracts", "time", "bilirubin", "chain", "thyroid", "zhi", "Type 1", or "cystic". From this filtered data each disease selected rows using keywords in the "disease trait". Gout and urate used the keywords "urate" and "gout", obesity used "obesity" and "body mass", \gls{t2d} used "diabetes", and metabolic syndrome used "syndrome". Kidney disease used the keywords "kidney" and "renal" and removed entries that had keywords of "transplant", "carcinoma","type", "stones","gout", "related", and "Diabetic kidney disease". The other disease gene lists used the filtered P-value data and used selected on keywords; for age-related macular degeneration, "age-related macular degeneration" was used. For Alzheimer's disease, "Alzheimer's disease" was used. For Parkinson's disease, "Parkinson's disease" was used, removing entries with the keyword "early". And for colerectal cancer, "Colorectal cancer" and "Colon cancer" were used. All keyword matching was case-insensitive.

```{r diseaseListKeywords, eval = FALSE, echo = FALSE}
gwas_interested <- gwas_cat[grep('metabolic syndrome|obesity|diabetes|urate|gout|body mass|lipid traits', gwas_cat$DISEASE.TRAIT, ignore.case = TRUE) ,]

#filter out potentially misleading gwas hits
kd<- gwas_cat %>% filter(grepl(DISEASE.TRAIT, pattern = 'kidney|renal', ignore.case=TRUE) & !grepl(DISEASE.TRAIT, pattern = 'transplant|carcinoma|Type|stones|gout|related')) %>% filter(DISEASE.TRAIT != "Diabetic kidney disease")

gwas_interested <- rbind(gwas_interested[grep("child|erectile|lean|autoantibodies|gestational|cancer|psychopharmacol|metaformin|metformin|obstructive|interaction|asthmatics|omega|pain|cataracts|time|bilirubin|chain|thyroid|zhi|Type 1|cystic", gwas_interested$DISEASE.TRAIT, invert = TRUE, ignore.case = TRUE),], kd)



obesity_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("obesity|body mass",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

t2d_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("diabetes",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

metsyn_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("Syndrome",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

gc_urate_gout_GR <-  gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("urate|gout",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]
```

```{r markdown2, eval = FALSE, include = FALSE}

### Selection database creation

It was decided that in order to store the results from the seletionTools pipeline in an efficient manner that a database should be used. This involved creating a database schema from scratch. The database schema was co-designed in consultation with Nick Burns and the initial loading scripts were created by Nick for use with MySQL (https://github.com/nickb-/SelectionDW_ETL). These initial scripts were further developed by myself and re-implemented them for use with PostgreSQL v9.6 (https://github.com/murraycadzow/SelectionDW_ETL). The functionality to load the inter-population statistics was also added later.

The schema of the database consists of 4 main data tables and 3 supplementary tables. The main data tables are comprised of intra-population selection statistics and inter-population statistics. The 3 supplementary tables provide annotation information to link a position id to a genomic position, link a statics id to the statistic name, and finally link a population id to a population name.

Custom Views were created to join the supplemental tables to the main tables.
```


#### PCA - eigenstrat {#pca}

The first 10 principle components were calculated using smartPCA v13050 from Eigensoft v6.0.1 [@Price2006]. All chromosomes were combined into a single \gls{vcf} file and then the independent markers were found by using a sliding window to remove markers that had an R^2^ > 0.2 in windows of 50 kbp and a slide of 5 markers. 

```{r eigenstrat code, engine='bash', eval = FALSE}
scratch=/Volumes/scratch/merrimanlab/murray/working_dir/
dir=$scratch/coreExome_selection/NZ_coreExome_1kgp/analysis/PCA/indiv_pops
#combine the chromosomes
bcftools concat \
  -O v \
  -o - 
  --threads 10 $(ls NZ_1KGP.chr*gz | sort -n -t'r' -k2) |\
bcftools view \
  -O z \
  -o NZ_1KGP_allchr.vcf.gz \
  -s $(grep -v 'NAD\|WPN\|EPN' ../../../data/nz_1kgp.panel | cut -f1 | tr '\n' ',') \
  --force-samples -

#find the independent markers
plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
  --maf 0.1 \
  --indep-pairwise 50 5 0.2 \
  --out NZ_1KGP_allchr

touch cases.txt

plink1.9b4.9 --vcf NZ_1KGP_allchr.vcf.gz \
  --extract NZ_1KGP_allchr.prune.in \
  --recode \
  --out NZ_1KGP_allchr_indep \
  --make-pheno cases.txt '*'

# create the eigenstrat file
echo -e "genotype: NZ_1KGP_allchr_indep.ped\nsnpname: \
NZ_1KGP_allchr_indep.map\nindivname: \
NZ_1KGP_allchr_indep.ped\noutputformat: \
EIGENSTRAT\ngenotypeoutname: \
NZ_1KGP_allchr_indep.eigenstratgeno\nsnpoutname: \
NZ_1KGP_allchr_indep.snp\nindivoutname: \
NZ_1KGP_allchr_indep.ind\nfamilynames: \
NO" > par.PED.EIGENSTRAT

convertf -p par.PED.EIGENSTRAT > eigen.log
smartpca.perl \
  -i NZ_1KGP_allchr_indep.eigenstratgeno \
  -a NZ_1KGP_allchr_indep.snp \
  -b NZ_1KGP_allchr_indep.ind  \
  -o NZ_1KGP_allchr_indep_eigen.pca \
  -p NZ_1KGP_allchr_indep_eigen \
  -e NZ_1KGP_allchr_indep_eigen.eval \
  -l NZ_1KGP_allchr_indep_eigen.log \
  -m 0
```

#### Admixture analysis {#admixture}

Admixture analysis was performed using ADMIXTURE v1.3.0 [@ref]. \gls{vcf} files for all autosomes were concatenated and the independent markers were selected by a moving window of 50 kbp sliding by 10 markers and removing markers with an R^2^ of more that 0.1. This was done using plink v1.9b4.9. Following this cross validation was performed to find the best value of K, for K 1 to 15. K = 11 had the lowest cross-validation error

```{r admixture k, engine = 'bash', eval = FALSE}
scratch=/Volumes/scratch/merrimanlab/murray/working_dir/
dir=$scratch/coreExome_selection/NZ_coreExome_1kgp/analysis/admixture

bcftools concat \
  -O v \
  -o - \
  --threads 10 $(ls NZ_1KGP.chr*gz | sort -n -t'r' -k2) |\
bcftools view \
  -O z \
  -o NZ_1KGP_allchr.vcf.gz \
  -s $(grep -v 'NAD\|WPN\|EPN' ../../data/nz_1kgp.panel | cut -f1 | tr '\n' ',') \
  --force-samples - 

plink1.9b4.9 \
  --vcf NZ_1KGP_allchr.vcf.gz \
  --indep-pairwise 50 10 0.1 \
  --out NZ_1KGP_allchr_admix

plink1.9b4.9 \
  --vcf NZ_1KGP_allchr.vcf.gz \
  --make-bed --extract NZ_1KGP_allchr_admix.prune.in \
  --out NZ_1KGP_allchr_admix
  
for K in $(seq 1 15)
do 
  admixture -s 123456 --cv NZ_1KGP_allchr_admix.bed $K -j20 | tee log${K}.out
done

grep CV log* | cut -d':' -f1,3 |tr -d ':' | sed 's/log\|\.out//g' > CV_error.txt
```


```{r, echo = FALSE, fig.cap='(ref:cv)'}
k_cv <- read.table('~/data/NZ_coreExome_1kgp/admixture/CV_error.txt', header = FALSE)
ggplot(k_cv, aes(x = V1, y = V2)) + geom_line() + geom_point() + labs(x = 'K',y = 'Cross Validation Error') + geom_point(data = k_cv %>% filter(min(V2) == V2), aes(x = V1, y = V2),color = 'red', shape = 4, size = 4, inherit.aes = FALSE) + theme_bw()
```

(ref:cv) Admixture cross-validation error for different values of K.

The cross validation of K from 1 to 15 resulted in K = 11 having the minimum cross validation error.

```{bash, eval = FALSE}
# to project 1000 genomes onto the Polynesians

#create reference population
#remove AMR and POL (and NZC) pops
cat ~/Murray/Thesis_backup/NZ_coreExome_1kgp/nz_1kgp.panel |\
grep -v 'POL\|AMR\|NZC' |\
awk '{if(NR > 1){print $1,$1}}' > 1kg_ref.list

plink1.9b4.9 --bfile NZ_1KGP_allchr_admix \
  --make-bed \
  --keep 1kg_ref.list \
  --out reference \
  --keep-allele-order

# create 'study population'
cat ~/Murray/Thesis_backup/NZ_coreExome_1kgp/nz_1kgp.panel |\
grep  'AMR\|NZC\|CIM\|TON\|NZM\|SAM' |\
awk '{if(NR > 1){print $1,$1}}' > pol_amr_nzc.list

plink1.9b4.9 --bfile NZ_1KGP_allchr_admix \
  --make-bed \
  --keep pol_amr_nzc.list \
  --out study \
  --keep-allele-order

# check bim files are identical
diff -s reference.bim study.bim

# select best K from CV testing
parallel -j 11 'admixture -s 123456 --cv  reference.bed {} -j10 | tee log{}.out ' ::: $(seq 1 15)

admixture -s 123456 -B reference.bed 9
# create study input P
cp reference.9.P study.9.P.in

admixture -s 123456 -P study.bed 9
```

```{r admixDataProjection, echo = FALSE}
ref <- read.table('~/data/NZ_coreExome_1kgp/admixture/projected/reference_bootstrap.9.Q')
ref_fam <- read.table('~/data/NZ_coreExome_1kgp/admixture/projected/reference.fam', header = FALSE)
names(ref_fam) <- c('FID','sample','PID','MID','SEX','AFF')
ref_fam <- left_join(ref_fam, panel %>% filter(!pop %in% c('NAD','EPN','WPN','POL')), by = 'sample')

study <- read.table('~/data/NZ_coreExome_1kgp/admixture/projected/study.9.Q')
study_fam <- read.table('~/data/NZ_coreExome_1kgp/admixture/projected/study.fam', header = FALSE)
names(study_fam) <- c('FID','sample','PID','MID','SEX','AFF')
study_fam <- left_join(study_fam, panel %>% filter(!pop %in% c('NAD','EPN','WPN','POL')), by = 'sample')
```

```{r cvproj, fig.cap = '(ref:cvproj)', echo = FALSE}
k_cv <- read.table('~/data/NZ_coreExome_1kgp/admixture/projected/CV_error.txt', header = FALSE)
ggplot(k_cv, aes(x = V1, y = V2)) + geom_line() + geom_point() + labs(x = 'K',y = 'Cross Validation Error') + geom_point(data = k_cv %>% filter(min(V2) == V2), aes(x = V1, y = V2),color = 'red', shape = 4, size = 4, inherit.aes = FALSE) + theme_bw()
```

(ref:cvproj) Admixture cross-validation error for different K values from projecting components from 1000 Genomes Project populations of AFR, EAS, EUR, and SAS

```{r, echo = FALSE}
# barplot of the reference proportions
cbind(ref_fam, ref) %>% gather(., "V","Q",9:NCOL(.)) %>% mutate(super_sample = paste0(super_pop,'_',sample), facet_pop = paste(super_pop, pop)) %>% ggplot(., aes(x = super_sample, y = Q)) + geom_bar(stat = "identity", position = 'stack', aes(fill = V)) + facet_wrap(super_pop~pop, scales = "free_x", ncol = 6) + theme_bw() + theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) + scale_y_continuous(expand = c(0,0)) 

```



```{r, echo = FALSE}
# admixed pops that were projected onto
#removed NZC for to make nice
cbind(study_fam, study) %>% gather(., "V","Q",9:NCOL(.)) %>% mutate(super_sample = paste0(super_pop,'_',sample), super_pop = factor(super_pop, levels = c("AMR", "POL","EUR"), ordered = TRUE)) %>% ggplot(., aes(x = super_sample, y = Q)) + geom_bar(stat = "identity", position = 'stack', aes(fill = V)) + facet_wrap(super_pop~pop, scales = "free_x", ncol = 4) +theme_bw() + theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) + scale_y_continuous(expand = c(0,0)) 
```



- V1 and V4 were EAS mostly
- V2 and V5 were AFR
- V7 was JPT
- V6 and V8 were EUR
- V9 was SAS


NZC is extremely similar to GBR and CEU

### GWAS

UK Biobank GWAS


#### 

#### Heritability Analysis

The \gls{gcta} v1.26.0 [@Yang2011; @Yang2011a] was used to calculate the proportion of heritability explained. First the genome was partitioned into chromosomes, and a \gls{grm} was created for each chromosome. Next genetic variance explained was calculated using a general population prevalence for gout of 2%.


```{r, engine='bash', eval=FALSE}

# load fam into R
# sample(10000, fam[AFF == controls]) -> controls.txt
# awk '{if($6 == 2){print $1"\t"$2}}' < condition.fam | cat - controls.txt > ids_keep.txt

ukbio_path=/Volumes/archive/merrimanlab/central_datasets/ukbiobank/plink/
# Subset samples
for i in $(seq 1 22)
do 
  plink2 --bed $ukbio_path/chr${i}impv1.bed \
            --bim $ubkbio_path/chr${i}impv1.bim_1kg_marker \
            --fam $ukbio_path/chrallimpv1.fam_allgout_allcontrols \
            --hwe 0.000001 \
            --maf 0.01 \
            --keep ult_ids_keep.txt \
            --make-bed \
            --out gout_chr${i} \
done
```

Calculate the genetic relationship matrix
```{r, engine = 'bash', eval = FALSE}
for i in $(seq 1 22)
do 
  gcta1.26.0 \
    --bfile gout_chr${i} \
    --chr ${i} \
    --make-grm-bin \
    --out ukbio_10ksample_grm_chr${i} \
    --thread-num 16 > grm_${i}.log  \
done
```

Calculate the genetic variance explained using a general population gout prevalence of 2%
```{r, engine = 'bash',eval = FALSE}
for i in $(seq 1 22) 
do 
  gcta1.26.0 \
    --grm ukbio_10ksample_grm_chr${i} \
    --pheno phenos.txt  \
    --prevalence 0.02 \
    --out var_chr${i} \
    --reml \
    --chr ${i} \
    --thread-num 16 \
done

```



### Variant Annotation

Variant annotation of \gls{vcf} files was performed using snpEff v4.2 [@snpeff] with the homo sapiens GRCh37 database.


### Pathway Analysis


<!-- Panther http://pantherdb.org -->

<!-- version 13.0 (released 2017-11-12) -->

<!-- for population lists used the "Functional classification viewed as pie chart" selected biological process and exported the results as a table -->

<!-- Analysis Type: PANTHER Overrepresentation Test (release 20170413) -->
<!-- - annotation set = pnather GO-slim biological process -->

Enrichr 

used enrichr [@Chen2013b; @Kuleshov2016] http://amp.pharm.mssm.edu/Enrichr/, specifically the pathway enrichment KEGG2016 table

the p-value is computed from the Fisher exact test which is a proportion test that assumes a binomial distribution and independence for probability of any gene belonging to any set

adjusted p-value: or q-value is an adjusted p-value using the Benjamini-Hochberg method for correction for multiple hypotheses testing

z-score: the rank based ranking is derived from running the Fisher exact test for many random gene sets in order to compute a mean rank and standard deviation from the expected rank for each term in the gene-set library and finally calculating a z-score to assess the deviation from the expected rank

combined score is computed by taking the log of the p-value from the Fisher exact test and multiplying that by the z-score of the deviation from the expected rank (c = log(p) * z)


significance was set as an adjusted p-value < 0.05


## Datasets

### 1000 Genomes Project Phase 3

<!--
@misc{1kgp_ftp,
keywords = {1KGP},
mendeley-groups = {PPARGC1Apaper,Datasets},
mendeley-tags = {1KGP},
title = {{1000 Genomes Project FTP}},
url = {ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/},
urldate = {2015-08-18}
}
-->

The \glsdesc{1kgp} was an international consortium that was established in 2007 to provide a comprehensive record of human genetic variation. The project consisted of three main data phases. A pilot phase that whole-genome sequenced 179 individuals from four populations at low coverage (2-4x), along with high coverage sequencing for two trios (mother, father, and child), and exon targeted sequencing for 697 individuals from seven populations [@1KGP2010]. The second main data phase provided sequencing data for 1092 individuals from 14 populations. This sequencing data was a combination of low coverage whole-genome and exon sequencing [@1KGP2012]. The third main phase (Phase 3) was a dataset consisting of low coverage whole-genome sequencing, deep exome sequencing, and dense \gls{snp} array genotyping for 2504 individuals from 26 populations [@1KGP2015snp]. The 1000 Genomes data set used was the Phase 3 release^[ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ accessed 20 March 2017].


```{r populations, results = 'asis', echo = FALSE}

read.csv('data/02-populations.csv', stringsAsFactors = FALSE) %>% left_join(., panel %>% group_by(pop) %>% tally(), by = 'pop') %>% filter(!pop %in% c("EPN","OMN","AXI","WPN","NAD") & superPop != "") %>% arrange(superPop, pop) %>% mutate(pop = if_else(pop %in% c("NZM","NZC","CIM","SAM","TON"), paste0(pop,'*'), pop))%>% select("Population" = pop, "Description" = description, n, "Genotype\nPlatform" = genotypePlatform) %>%   knitr::kable(format = 'latex', booktabs = TRUE, caption = '(\\#tab:populations) Description of Populations') %>% kableExtra::group_rows("African Super Population (AFR)", 1,7) %>% kableExtra::group_rows("Ad Mixed American Super Population (AMR)", 8, 11) %>% kableExtra::group_rows("East Asian Super Population (EAS)", 12, 16) %>% kableExtra::group_rows("European Super Population (EUR)", 17, 22) %>% kableExtra::group_rows("Polynesian Super Population (POL)*", 23, 26) %>% kableExtra::group_rows("South Asian Super Population (SAS)", 27, 31) %>% kableExtra::add_footnote("NZC, NZM, TON, SAM, and CIM are from 'Genetics of Aoteroa' and are not 1000 Genomes Project populations", notation = "symbol") %>% kableExtra::kable_styling(font_size = 8)
```


### Genetics of Gout in Aotearoa

The genetics of Gout in Aotearoa study is a case-control cohort with recruitment mainly from the Auckland, Wellington, Christchurch and Dunedin regions of New Zealand. Individuals were asked to fill in a questionnaire regarding demographics information, clinical information, and food consumption at the time of recruitment. Individuals from this study were genotyped on Illumina CoreExome v24  \gls{snp} array.

```{r, eval = FALSE, echo = FALSE, include = FALSE}


<!--
whole genome low-coverage resequenced, or exome resequence data.
#### Axiom

- about
- population

| | obs missing (n) | Maori AXIOM
---|---|---
Number | - | 71 
Sex (% male) | - | 64.7
Gout cases (%) | - | 49.3
Mean BMI (range) | 1 | 34.5 (22.1 to 56.1)
Diabetes (%) | 3 | 21.1
Mean grandparent ancestry (range) | - | 0.916 (0.625 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- markers
- density


#### Omni


| | obs missing (n) | Samoan OMNIexpress
---|---|---
Number | - | 96
Sex (% male) | - | 74
Gout cases (%) | - | 50.0
Mean BMI (range) | - | 36.1 (20.5 to 93.4)
Diabetes (%) | - | 12.5
Mean grandparent ancestry (range) | - | 0.997 (0.875 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- about
- population
- markers
- density
-->
```
#### CoreExome

The Infinium CoreExome-24 beadchip is a genotyping platform available from Illumina and comprises a core set of 551,839 markers. Genotyping quality control was performed following the protocol from @Guo2014 and the Illumina GenomeStudio best practice guidelines. Illumina’s GenomeStudio v2011.1 genotyping module v1.9.4 was used for the initial calling of genotypes. Samples were exported from Genome Studio that had a call rate > 98%, markers were zeroed if they were < 95%. Individuals who had not reported their sex were assigned their genetic sex where possible. Individuals were removed where genetic and reported sex did not match. The cohort was checked for genotype consistency between duplicated markers, with duplicates subsequently removed.

Samples were also checked for outliers in heterozygosity and depression of genetic variation. 

Markers were subsetted to only include bi-allelic \gls{snp}s, with a final marker number of `r NROW(markers)` and density of `r  lapply(1:22, function(x){diff(markers %>% filter(chrom ==x) %>% arrange(chrom_start) %>% pull(chrom_start))}) %>% unlist() %>%  mean() %>% round_dp(., 0)` bp/marker.

Relatedness between individuals was assessed through inheritance by state using Plink2 (v1.9b3.32) and a pedigree of created to 
Duplicates and first degree relations were excluded.

Hardy-Weinberg equilibrium of markers was checked for European, East Polynesian, and West Polynesian populations (3 or more grandparents self reported ethnicity) using an exact test in plink2 and variants were removed that had a Bonferroni multiple testing corrected p < 0.05.

The genetic ancestry determined through \gls{pca} was compared with self reported ethnicity and individuals were removed where there was disagreement.





Selection of samples to form the populations used in the selection analyses
Gout affection was determined by the American College of Rheumatology criteria



A single individual was randomly selected from family groups identified through identity by state analysis. Individuals who had a mismatch between self reported and genetic ancestry were also removed. Principle components 2 and 4 were found to provide the greatest separation between Europeans, East Polynesians, and West Polynesians. Individuals reporting 4 grandparents of Caucasian, NZ Maori, CI Maori, Samoan, and Tongan ancestry were used to define the threshold values. Thresholds were calculated using mean +/- 2 SD for PC2 and PC4 for each population group. Once thresholds were calculated all samples were filtered so that only those that lay within a boundary remained. Remaining samples were then randomly sampled to form groups of 100 individuals, where possible trying to match general population prevalence for gout.

```{r, include = FALSE, eval = FALSE}
Marker Categories | Number of Markers
---|---
In RefSeq Genes | 374,258 (399,009 within 10 kb)
In RefSeq Exons | 269,186
In RefSeq Promoter Regions | 13,990
In ADME Genes | 11,276 (12,455 within 10 kb)
In ADME Exons | 9,314
MHC (Extended MHC) | 3,940 (5,628)
Overlap with Genes in COSMIC | 365,135
Overlap with Genes in Gene Ontology | 96,331
Nonsense Markers | 14,994
Missense Markers | 219,162
Synonymous Markers | 14,747
Silent Markers | 8,850
Mitochondrial Markers |351
Indels | 12,436

mean call rate
mean missing
number of snps passing qc
number of snps used for selection


(http://www.illumina.com/content/dam/illumina-marketing/documents/products/datasheets/datasheet_human_core_exome_beadchip.pdf, accessed 16 Jan 2017)
```

Clinical Information





```{r, warning= FALSE, message = FALSE, echo = FALSE}
ce_clinical_table() %>% kable(., col.names = c("", rep(c("Control","Gout"), 3)), booktabs = TRUE, format = 'latex', caption = ' (\\#tab:clinInfoCE) Clinical information for each core Exome population') %>% add_header_above(., c("", "European" = 2, "Eastern Polynesian"= 2, "Wester Polynesian" = 2)) %>% kable_styling(latex_options = 'scale_down')
```







```{r, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE, eval = FALSE}
#knitr::kable(ce_populations_table(), longtable = TRUE, format = 'pandoc', booktabs = TRUE , caption = 'Clinical information for New Zealand Populations in selection analysis')
```



```{r, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE}
ce_pop_table <- ce_populations_table()
#names(ce_pop_table) <- c("pop","n","Age","Sex (% Male)","BMI","Waist","Percent Diabetes","Percent Gout")
knitr::kable(data.frame(ce_pop_table), caption = '(\\#tab:cePopTable) Clinical information for New Zealand Populations in selection analysis',align = 'lcrrrrrr', col.names = c("pop","n","Age","Sex (% Male)","BMI","Waist","Diabetes (%)","Gout (%)", "Kidney Disease (%)","Heart Problems (%)"), booktabs = TRUE, format = 'latex' ) %>% kable_styling(latex_options = 'scale_down') 
```

Analysis groups were created by using genetic ancestry for the following populations: \glsdesc{nzm}, \glsdesc{cim}, \glsdesc{sam}, \glsdesc{ton}, and \glsdesc{nzc} and unenriching for gout. To unenrich for gout, population specific prevalence based on @Winnard2013 of 2.3% for \gls{nzc}, 7.7% for \gls{nzm}, and 8.6% for \gls{cim}, \gls{sam}, and \gls{ton} were used and individuals were randomly sampled. Final sample population prevalence of 2.0% (\gls{nzc}), 7.0% (\gls{nzm}), 45.0% (\gls{cim}), 12.0% (\gls{sam}), and 54.0% (\gls{ton}) were obtained.

- about
- population
- markers
- density

Table \@ref(tab:cePopTable) shows the break down of 





### Selection dataset {#selectionDataset}

#### Sample selection

Principle components were calculated for all individuals genotyped on the coreExome mircoarray using SmartPCA (EIGENSOFT v6.0.1, see section \@ref(pca)) using 2858 ancestry informative markers (@Guo2014 supplementary material). The first 10 eigenvectors were outputted, with no outlier removal or population size limit. Individuals were removed who did not match between self reported ethnicity of grandparents and their genetic ancestry, or if they had self reported their ethnicity as unknown.

Principle component 2 was identified as providing the best separation of European ancestry from Polynesian ancestry, and PC4 had the best separation of East Polynesian from West Polynesian populations. Individuals were then filtered for European or Polynesian ancestry. To determine the boundaries of the population groups, the mean +/- 1 SD for PC2 and 4 were used (Figure \@ref(fig:cePCA)).

(ref:cePCA) Principle compenents 2 and 4 for individuals used in the selection analysis.

```{r cePCA, fig.cap = '(ref:cePCA)', echo = FALSE, out.width = "70%"}
knitr::include_graphics('images/02_methods/pca_plot.png')
```


#### Core Exome - Filter individuals and markers 

To create a data set to calculate selection statistics, a subset of the individuals genotyped on the Illumina CoreExome chip were combined with all of the individuals in the \gls{1kgp} phase 3 release. Before the data sets could be combined there were a series of steps that were performed.

The first step was to identify and remove individuals who had failed quality control, and keep only the individuals who had been selected through \gls{pca} and had a genotyping rate of at least 95%. Markers were filtered to remove \gls{indel}s so that only \gls{snp}s remained.

```{r, engine = 'bash', eval = FALSE}
parallel -j 11 '
  plink2 \
    --bfile src_data/QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff \
    --recode vcf \
    --out QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff.chr{} \
    --chr {} \
    --remove src_data/QC1_7-BlanketExclusions.txt \
    --keep coreExome_selection_keep_ids.txt \
    --allow-no-sex \
    --snps-only no-DI \
    --geno 0.95
    ' ::: $(seq 1 22)
```

The second step was to ensure that all the CoreExome markers were normalised against the hs37d5 human reference. This was to make sure the REF/ALT alleles would match with the \gls{1kgp} phase 3 for a successful merge after phasing and subject selection. SHAPEIT2 was then used to find SNP alleles that disagreed with the \gls{1kgp} haplotype reference and phase the CoreExome markers. This step also reduced markers to bi-allelic positions and removed duplicate positions.

```{r, engine = 'bash', eval = FALSE}
parallel -j 11 '
  bcftools norm \
    -N \
    --rm-dup any \
    --check-ref s \
    -f /Volumes/archive/merrimanlab/reference_files/FASTA/hs37d5/hs37d5.fa \
    -O v QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff.chr{}.vcf | \
  bcftools view \
    -m 2 \
    -M 2  \
    -O z \
    -o QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.vcf.gz \
  ' ::: $(seq 1 22)

```

After normalisation, the \gls{vcf} files were phased using the 1000 Genomes Project phase 3 reference haplotypes as described in section \@ref(phase).

#### Merge NZ coreExome with 1000 Genomes Project

In order to efficiently merge the data sets, the intersection of the markers from the \gls{1kgp} dataset and the CoreExome was found. This was done by extracting the marker positions and alleles from the coreExome data and then matching these to the marker positions extracted from the \gls{1kgp} phase 3. The \gls{1kgp} phase 3 markers were also filtered to remove non bi-allelic \gls{snp}s.

```{r, engine = 'bash', eval = FALSE}
# extract markers from core exome
archive1kg=/Volumes/archive/merrimanlab/reference_files/VCF/1000Genomes_vcf_files
parallel '
  zgrep \
    -v "^#" QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.phased.vcf.gz |\
    cut -f1,2,4,5 > coreExome_chr{}_biallelic_markers.txt 
    ' ::: $(seq 1 22)

# extract 1000 Genomes markers
# working dir: /Volumes/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5
parllel '
  bcftools view \
    -O v \
    -m 2 \
    -M 2 \
    -v snps \
    -o - \
    $archive1kg/Phase3_March2017/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz |\
  grep -v "^#" |\
  cut -f 1,2,4,5 > 1kgp_chr{}_biallelic_markers.txt 
  ' ::: $(seq 1 22)
```


An R script was created in order to merge the two marker lists based on chromosome position and the reference and alternate alleles 

```{r, eval=FALSE}
# on merriserver
scratch="/Volumes/scratch/merrimanlab/murray/working_dir/"
ce_markers <- data.frame()
tmp_list <- list()
for(i in 1:22){
  tmp_list[[i]] <- read.table(file = paste0(
    scratch,'coreExome_selection/NZ_coreExome_1kgp/data/NZ_coreExome/coreExome_chr',
    i,'_biallelic_markers.txt'), header=FALSE)
}
ce_markers <- do.call(rbind, tmp_list)

kg_markers <- data.frame()
tmp_list2 <- list()
for(i in 1:22){
  tmp_list2[[i]] <- read.table(file= paste0(
    scratch,'coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5/1kgp_chr',
    i,'_biallelic_markers.txt'), header=FALSE)
  tmp_list2[[i]] <-  tmp_list2[[i]][ tmp_list2[[i]][,2] %in% tmp_list[[i]][,2],]
 
  print(i)
}
kg_markers <- do.call(rbind, tmp_list2)
ce_kg <- merge(ce_markers, kg_markers, by = c("V1","V2","V3","V4"))
write.table(file = 'ce_1kg_matched_markers.txt', ce_kg[,c(1,2)], row.names = FALSE, col.names=FALSE, quote=FALSE)
```

Once the combined marker list was created, both the CoreExome and \gls{1kgp} data sets had have their markers filtered to this consensus set.
```{r, engine = 'bash', eval = FALSE}
# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5
# filter 1000 Genomes markers
archive1kg=/Volumes/archive/merrimanlab/reference_files/VCF/1000Genomes_vcf_files
parallel '
  bcftools view 
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.biallelic_ce_1kg_matched.vcf.gz \
    $archive1kg/Phase3_March2017/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz 
  ' ::: $(seq 1 22)


# working dir: /Volumes/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/NZ_coreExome/
# filter coreExome markers
parallel '
  bcftools view \
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o NZ_coreExome.chr{}.norm.phased.biallelic_ce_1kg_matched.vcf.gz \
    QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.phased.vcf.gz 
  ' ::: $(seq 1 22)

# merge 1kgp and nz coreexome
# working dir: /Volumes/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/
parallel 
  'bcftools merge \
    -O z \
    -o NZ_1KGP.chr{}.phased.vcf.gz \
    Phase3_v5/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.biallelic_ce_1kg_matched.vcf.gz \
    NZ_coreExome/NZ_coreExome.chr{}.norm.phased.biallelic_ce_1kg_matched.vcf.gz 
  ' ::: $(seq 1 22)
```

Sample identifiers were then updated to match the panel file that describe the population and super population an individual belonged to.
```{r, engine = 'bash', eval = FALSE}
# working dir: /Volumes/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/
for i in $(seq 1 22)
do 
  zcat NZ_1KGP.chr$i.phased.vcf.gz |\
  head -1000 |\
  grep '^#CHROM' |\
  cut -f10- |\
  tr '\t' '\n' |\
  awk -F "_" '{if(NF ==1 ) {print $1 "\t" $1}else{print $1"_"$2"\t" $2}}' |\
  bcftools reheader \
    -s /dev/stdin/ \
    -o NZ_1KGP.chr$i.phased.sample_updated.vcf.gz \
    NZ_1KGP.chr$i.phased.vcf.gz
done
```

Principle components for the merged \gls{1kgp} data and the New Zealand samples showed in the first two components that the \gls{afr}, \gls{eur}, \gls{sas} super populations all formed separate groupings. \gls{eas} and \gls{pol} were extremely similar in PC1 but the \gls{pol} populations were spread with PC2, with the majority of the spread being accounted for by the Eastern Polynesian populations whereas the Western Polynesian populations had a tight grouping at -0.025 on PC2, slightly below the \gls{eas} group. This can be observed when PC6 is used to separate the Polynesian populations (Figure \@ref(fig:polPCA)).

(ref:allpopPCA) Principle components 1 and 2 for all populations, coloured by super population grouping.

```{r allpopPCA, fig.cap = '(ref:allpopPCA)', echo = FALSE}

eigen <- read.table('~/data/NZ_coreExome_1kgp/PCA/indiv_pops/NZ_1KGP_allchr_indep_eigen.pca.evec', stringsAsFactors = FALSE)

eigen <- eigen %>% select("sample" = V1, everything()) %>% left_join(., panel, by = 'sample') %>% filter(!pop %in% c('WPN','EPN','NAD'))
names(eigen)[2:11] <- paste0("PC",1:10)
eigen %>%  ggplot(., aes(x = PC1, y = PC2, colour = super_pop)) + geom_point() + theme_bw()  + guides(colour  = guide_legend(title = "Super Population"))
```

(ref:eurPCA) Principle components 1 and 2 for populations of the European Super Population.

```{r eurPCA, fig.cap = '(ref:eurPCA)', echo = FALSE}
#eigen %>%  filter(super_pop == 'EUR') %>% ggplot(., aes(x = PC1, y = PC2, colour = pop)) + geom_point() + theme_bw() + guides(colour  = guide_legend(title = "Population"))

eigen %>%  filter(super_pop == 'EUR') %>% ggplot(., aes(x = PC1, y = PC2, shape = pop, colour = super_pop)) + geom_point(size = 2) + theme_bw() + scale_color_manual(values = c(EUR = '#00BFC4')) + guides(shape  = guide_legend(title = "Population"), colour = guide_legend(title = "Super Population")) + scale_shape_manual(values = c(CEU = 0, NZC = 1, GBR = 2, IBS = 3, FIN = 4, TSI = 5))
```

(ref:polPCA)  Principle components 2 and 6 for the Polynesian populations.

```{r polPCA, fig.cap = '(ref:polPCA)', echo = FALSE}
eigen %>%  filter(super_pop == 'POL') %>% ggplot(., aes(x = PC6, y = PC2, shape = pop, colour = super_pop)) + geom_point(size = 2) + theme_bw() + scale_color_manual(values = c(POL = '#619CFF')) + scale_shape_manual(values = c("CIM" = 0,"NZM" = 1, "TON" = 2, "SAM" = 3)) + guides(size = FALSE) + guides(shape  = guide_legend(title = "Population"), colour = guide_legend(title = "Super Population"))
```


There was no distinction between the \gls{ceu}, \gls{gbr}, and \gls{nzc} populations (Figure \@ref(fig:eurPCA)), this indicated that the use of chip versus sequence data wasn't a major source of variability in the dataset. In the combined dataset the Polynesian populations where split into Eastern and Western Polynesian sub-groups with PC6 (Figure \@ref(fig:polPCA)).


### Reference datasets

Table \@ref(tab:refDatasets) provides the name of the dataset and the date it was accessed and the url from which the dataset was downloaded. These datasets were incorporated into many of the analysis steps.

Table: (\#tab:refDatasets) _Reference Datasets_

| Name | Date | URL |
|:-------------------------------|--------------------------|--------------------------------------------------------------|
|1000 Genomes Project Phase 3 release 5 |17 Sept 2014| |
|1000 Genomes Project Phase 3 release 5 |20 Mar 2017| http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ |
|1000 Genomes Phase 3 phased haplotypes |14 Dec 2014| https://mathgen.stats.ox.ac.uk/impute/1000GP_Phase3.html |
|Human Genome Reference FASTA | 5 Aug 2014 | ftp://ftp.1000genomes.ebi.ac.uk:21/vol1/ftp/technical/reference/phase2_reference_assembly_sequence/hs37d5.fa.gz |
|Human Ancestral Allele FASTA | 6 Aug 2014 | ftp://ftp.ensembl.org/pub/release-66/fasta/ancestral_alleles/homo_sapiens_ancestor_GRCh37_e66.tar.bz |


