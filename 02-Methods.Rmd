---
output:
  pdf_document: default
  html_document: default
---


# Methods/Data
```{r, echo = FALSE, message = FALSE, warning= FALSE}
library(tidyverse)
library(pander)
source("scripts/methods_tables.R")

```

```{r, echo = FALSE, inlcude = FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

```{r, linewidth=80, tidy=TRUE, include = FALSE, eval=FALSE}
# this is an example of how linewidth will cut the output short, however it doesn't wrap the code chunk
a <- '## "stx2A; shiga-like toxin II A subunit encoded by bacteriophage BP-933W; K11006 shiga toxin subunit A" '
a
```

## Methods

### Phasing {#phase}


Phasing was performed using SHAPEIT2 v2.r837 [@Delaneau2013] using the \gls{1kgp} haplotype panel. There were two steps involved for phasing of genotypes. The first was to check the markers were aligned with the markers in the reference haplotypes. This was done using the SHAPEIT2 -check flag.

```{bash, eval = FALSE, echo =TRUE}
# Check alignment of markers against reference haplotypes
# ? = chromosome
shapeit2 \
-check \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
  --output-log coreExome_norm.chr?.checked \
  -T 12
```

The second step was the actual phasing step. 


```{bash, eval = FALSE, echo = TRUE}
# Run phasing against reference haplotypes
# Exclude misaligned markers
# Use 8 threads
# ? = chromosome
shapeit2 \
-M genetic_map_chr?_combined_b37.txt \
--input-vcf coreExome_norm.chr?.vcf.gz \
--input-ref 1000GP_Phase3_chr?.hap \
  1000GP_Phase3_chr?.legend \
  1000GP_Phase3.sample \
--output-max coreExome_norm.chr?.phased \
--exclude-snp coreExome_norm.chr?.checked.snp.strand.exclude \
-T 8


# Convert haps to vcf.gz
shapeit2 \
-convert \
--input-haps coreExome_norm.chr?.phased \
--output-vcf coreExome_norm.chr?.phased.vcf 
```




### Selection Statistics

#### PopGenome {#popgenomeMethods}

Ancestral allele - The ancestral allele was used as had been annotated from the 1000 Genomes Phase 3 \gls{vcf} file where possible. A new sample identified as 'Ancestor' was included into the \gls{vcf} and for each marker the genotype for this sample was set as the homozygote for either the reference or alternate allele dependant on the ancestral allele matching, otherwise the Ancestor genotype was set to missing.

When the \gls{vcf} files were loaded into the R package PopGenome (v2.2.3, @Pfeifer2014) populations were identified using panel files which were whitespace delimited files with sample id, population, and super population as the columns. The outgroup population was set to be that of the Ancestor sample.

for \gls{td}, \gls{fwh}, \gls{fld}, \gls{flf}, and \gls{ze} a significance threshold was created using the empirical distribution with significance being designated as being in the either the 1st or 99th percentile, and negative for the lower tail, or positive for the upper tail.

#### SelectionTools {#selectionTools}

SelectionTools v1.1 [@Cadzow2014] was used to generate the following statistics as per Table \@ref(tab:seltoolStats)
Ancestral allele was assigned using the ancestral allele fasta (see table ??) 

Each population was filtered for a \gls{maf} of 0.01 and a \gls{hwe} exact test of 10^-6^

\gls{ihs}, \gls{nsl}, and \gls{xpehh} normalisation was done using norm as part of selscan v1.1.0b [@Szpiech2014] using a significance level of 99%

Table: (\#tab:seltoolStats) 


| Statistic | Program | Window Size | Reference |
|:----------------|:------------:|:-------------:|:---------------|
| _Window based_ | | | |
| Tajima's D | Vcftools | 30 kb | @Tajima1989|
| Fay and Wu's H | Variscan | 30 kb | @fay2000hitchhiking|
| Fu and Li's D | Variscan | 30 kb | @Fu1993|
| Fu and Li's F | Variscan | 30 kb | @Fu1993|
| $\eta$ (total number of mutations) |Variscan| 30 kb | |
| $\eta$~E~ (number of external mutations) |Variscan| 30 kb | |
| $\pi$ |Variscan| 30 kb | |
| S |Variscan| 30 kb | |
| mean F~ST~ | Vcftools| | |
| _Haplotype Based_ | | | |
| sL by allele | Selscan | | |
| sL1 | Selscan | | |
| unstandardised nSL |Selscan | | |
| standardised nSL |Selscan | | |
| ihh by allele | Selscan | | |
| unstandardised iHS | Selscan | | |
| standardised iHS | Selscan norm | | |
| iHH by population 1 | Selscan | | |
| iHH population 2 | Selscan | | |
| unstandardised XP-EHH | Selcan | | |
| standardised XP-EHH | Selscan norm | | |
| _Frequency_ | | | |
| Minor allele frequency | | | |
| Derived allele frequency | | | |

<!--
- Tajima's D (Vcftools) [@Tajima1989]|
- Fay and Wu's H  (Variscan) [@fay2000hitchhiking]|
- Fu and Li's D | Variscan  [@Fu1993]|
- Fu and Li's F | Variscan | 30 kb | [@Fu1993]|
- Eta (variscan) total (minimum number) number of mutations ($\eta$) 
- Eta E (variscan) number of external mutations ie number of derived singletons
- Pi (variscan) nucleotide diversity ($\pi$)
- S (variscan) number of segregating sites
- mean F~ST~ Vcftools

Haplotype based

- 



Gene
- Ka/Ks
-->

### Disease Gene Lists {#diseaselist}

Lists were filtered for P <  5x10^-8^. From the filtered results the kidney disease gene list was created by filtering the "disease trait" column to select rows with the keywords "kidney" or "renal". Rows were then removed that had the keywords "transplant", "carcinoma", "Type", "stones", "gout", "related", or "Diabetic kidney disease". For the gout, urate, obesity, \gls{t2d}, and metabolic syndrome gene lists the following keywords were used on the "disease trait" column to select rows of the P-value filtered data: "metabolic syndrome", "obesity", "diabetes", "urate", "gout", "body mass", and "lipid traits". This subset was then filtered to remove rows containing these keywords in the "disease trait" column: "child", "erectile", "lean", "autoantibodies", "gestational", "cancer", "psychopharmacol", "metaformin", "metformin", "obstructive", "interaction", "asthmatics", "omega", "pain", "cataracts", "time", "bilirubin", "chain", "thyroid", "zhi", "Type 1", or "cystic". From this filtered data each disease selected rows using keywords in the "disease trait". Gout and urate used the keywords "urate" and "gout", obesity used "obesity" and "body mass", \gls{t2d} used "diabetes", and metabolic syndrome used "syndrome". The other disease genelsits used the filtered P-value data and used selected on keywords; for age-related macular degeneration, "age-related macular degeneration" was used. For Alzheimer's disease, "Alzheimer's disease" was used. For Parkinson's disease, "Parkinson's disease" was used, removing entries with the keyword "early". And for colerectal cancer, "Colorectal cancer" and "Colon cancer" were used. All keyword matching was case-insensitve.

```{r, eval = FALSE}
gwas_interested <- gwas_cat[grep('metabolic syndrome|obesity|diabetes|urate|gout|body mass|lipid traits', gwas_cat$DISEASE.TRAIT, ignore.case = TRUE) ,]

#filter out potentially misleading gwas hits
kd<- gwas_cat %>% filter(grepl(DISEASE.TRAIT, pattern = 'kidney|renal', ignore.case=TRUE) & !grepl(DISEASE.TRAIT, pattern = 'transplant|carcinoma|Type|stones|gout|related')) %>% filter(DISEASE.TRAIT != "Diabetic kidney disease")

gwas_interested <- rbind(gwas_interested[grep("child|erectile|lean|autoantibodies|gestational|cancer|psychopharmacol|metaformin|metformin|obstructive|interaction|asthmatics|omega|pain|cataracts|time|bilirubin|chain|thyroid|zhi|Type 1|cystic", gwas_interested$DISEASE.TRAIT, invert = TRUE, ignore.case = TRUE),], kd)



obesity_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("obesity|body mass",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

t2d_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("diabetes",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

metsyn_GR <- gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("Syndrome",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]

gc_urate_gout_GR <-  gwas_genes_ucscGR[gwas_genes_ucscGR$SYMBOL %in% unique(unlist(strsplit(gwas_interested[grep("urate|gout",gwas_interested$DISEASE.TRAIT, ignore.case = TRUE),]$REPORTED.GENE.S., ', '))),]
```



### Selection database creation

It was decided that in order to store the results from the seletionTools pipeline in an efficient manner that a database should be used. This involved creating a database schema from scratch. The database schema was co-designed in consultation with Nick Burns and the initial loading scripts were created by Nick for use with MySQL (https://github.com/nickb-/SelectionDW_ETL). These initial scripts were further developmented by myself and reimplemented them for use with Postgresql v9.6 (https://github.com/murraycadzow/SelectionDW_ETL). The functionality to load the inter-population statistics was also added later.

The schema of the database consists of 4 main data tables and 3 supplementary tables. The main data tables are comprised of intra-population selection statistics and inter-population statistics. The 3 supplementary tables provide annotation information to link a posistion id to a genomic position, link a statics id to the statistic name, and finally link a population id to a population name.

Custom Views were created to join the supplemental tables to the main tables.

```
#selectiondw_ETL


```



#### PCA - eigenstrat
```{r, engine='bash', eval = FALSE}
dir=/Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/
#combine the chromosomes
bcftools concat \
  -O z \
  -o combined_super_all.vcf.gz \
  --threads 10 \
  $(ls $dir/NZ_coreExome_1kgp/data/dbload/fixed_vcf/combined/combined_super_chr*vcf.gz |\
  sort -t r -k12n)

#find the independent markers
plink2 \
  --vcf combined_super_all.vcf.gz \
  --maf 0.1 \
  --indep-pairwise 50 5 0.2 \
  --out combined_super_all

touch cases.txt

plink2 \
  --vcf combined_super_all.vcf.gz \
  --extract combined_super_all.prune.in \
  --recode \
  --out combined_super_all_indep \
  --make-pheno cases.txt '*'

# create the eigenstrat file
echo -e "genotype: combined_super_all_indep.ped\nsnpname:\
combined_super_all_indep.map\nindivname: \
combined_super_all_indep.ped\noutputformat: \
EIGENSTRAT\ngenotypeoutputname: \
combined_super_all_indep.eigenstratgeno\nsnpoutname: \
combined_super_all_indep.snp\nindivoutname: \
combined_super_all_indep.ind\nfamilynames: \
NO" > par.PED.EIGENSTRAT

convertf -p par.PED.EIGENSTRAT > eigen.log
smartpca.perl \
  -i combined_super_all_indep.eigenstratgeno \
  -a combined_super_all_indep.snp \
  -b combined_super_all_indep.ind  \
  -o combined_super_all_indep_eigen.pca \
  -p  combined_super_all_indep_eigen \
  -e combined_super_all_indep_eigen.eval \
  -l combined_all_indep_eigen.log \
  -m 0
```

#### admixture analysis
```{r, engine = 'bash', eval = FALSE}
dir=/Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection

bcftools concat -O z -o combined_super_all.vcf.gz \
--threads 10 \
$(ls $dir/NZ_coreExome_1kgp/data/dbload/fixed_vcf/combined/combined_super_chr*vcf.gz |\
sort -t r -k12n)

plink2 \
  --vcf combined_super_all.vcf.gz \
  --indep-pairwise 50 5 0.1 \
  --out combined_super_all_admix

plink2 \
  --vcf combined_super_all.vcf.gz \
  --make-bed --extract combined_super_all_admix.prune.in \
  --out core_exome_admix
  
for K in $(seq 1 15)
do 
  admixture -s 123456 --cv core_exome_admix.bed $K -j20 | tee log${K}.out
done

grep CV log* | cut -d':' -f1,3 |tr -d ':' | sed 's/log\|\.out//g' > CV_error.txt
```

### GWAS

Uk Biobank GWAS


#### 

#### Heritability Analysis

The GCTA v1.26.0 [@gctaref] was used to calculate the proportion of heritability explained. A genetic relationship matrix was calculated 


```{r, engine='bash', eval=FALSE}

# load fam into R
# sample(10000, fam[AFF == controls]) -> controls.txt
# awk '{if($6 == 2){print $1"\t"$2}}' < condition.fam | cat - controls.txt > ids_keep.txt

ukbio_path=/Volumes/BiocArchive/archive/merrimanlab/central_datasets/ukbiobank/plink/
# Subset samples
for i in $(seq 1 22)
do 
  plink2 --bed $ukbio_path/chr${i}impv1.bed \
            --bim $ubkbio_path/chr${i}impv1.bim_1kg_marker \
            --fam $ukbio_path/chrallimpv1.fam_allgout_allcontrols \
            --hwe 0.000001 \
            --maf 0.01 \
            --keep ult_ids_keep.txt \
            --make-bed \
            --out gout_chr${i} \
done
```

Calculate the genetic relationship matrix
```{r, engine = 'bash', eval = FALSE}
for i in $(seq 1 22)
do 
  gcta1.26.0 \
    --bfile gout_chr${i} \
    --chr ${i} \
    --make-grm-bin \
    --out ukbio_10ksample_grm_chr${i} \
    --thread-num 16 > grm_${i}.log  \
done
```

Calculate the genetic variance explained using a general population gout prevalence of 2%
```{r, engine = 'bash',eval = FALSE}
for i in $(seq 1 22) 
do 
  gcta1.26.0 \
    --grm ukbio_10ksample_grm_chr${i} \
    --pheno phenos.txt  \
    --prevalence 0.02 \
    --out var_chr${i} \
    --reml \
    --chr ${i} \
    --thread-num 16 \
done

```


### Variant calling from sequence data

A pipeline for calling genetic variation from whole genome re-sequence data was implemented based on the best practices for the Genome Analysis ToolKit (GATK) v3.6  [@DePristo2011;@mckenna2010genome]. This entire pipeline was implemented and automated on the NeSI PAN cluster and automated to process each sample^[www.github.com/merrimanlab/NeSI_GATK/]. The automation involves a wrapper program that given a list of samples will initiate transfer of the raw sequences to the cluster, then initiate the processing pipeline, and upon completion of the processing pipeline transfer the outputted data back before proceeding to the next sample in the batch. 

#### Alignment of reads
Paired end Fastq files were split into chunks of smaller files containing no more than 12.5 million reads per chunk. each paired chunk was then aligned to the human reference genome (build GRCh37) containing autosomes, sex chromosomes, rCRS mitochondrial sequence (AC:NC_012920), alternate contigs, as well as decoy sequence. Alignment was performed using the Burrows Wheeler Transform Aligner (BWA, v0.7.12)[@Li2010]. 

```{bash, eval = FALSE}
# align
bwa mem -M -t ${SLURM_JOB_CPUS_PER_NODE} \
  -R ${RG} $REF $DIR/temp/R1_${i}.fastq.gz $DIR/temp/R2_${i}.fastq.gz |\
samtools view -bh - > $DIR/temp/${sample}_aligned_reads_${i}.bam

```


#### Bam Sort and Merge

The unsorted bam files for each chunk outputted from the alignment stage were then individually sorted into chromosome coordinate order using the picardtools (v2.10) [@picardref] sortSam module. Once all chunks were sorted they were merged into a single bam file for the sample using picardtools (v2.1.0) MergeSamFiles module.


```{bash, eval = FALSE}

# sort
java -Xmx8g -jar $EBROOTPICARD/picard.jar SortSam \
  INPUT=$DIR/temp/${sample}_aligned_reads_${i}.bam \
  OUTPUT=$DIR/temp/${sample}_sorted_${i}.bam \
  SORT_ORDER=coordinate \
  CREATE_INDEX=true \
  TMP_DIR=$DIR

# merge
java -Xmx19g -jar $EBROOTPICARD/picard.jar MergeSamFiles \
  $(sed 's/^/I=/g' < temp/sorted_bams.txt | tr '\n' ' ') \                               
  OUTPUT=$DIR/temp/${sample}_gathered.bam \
  USE_THREADING=true \
  CREATE_INDEX=true \
  SORT_ORDER=coordinate                                                    
```

#### Mark Duplicates

The bam file for the sample then had PCR duplicates marked using the Mark Duplicates module of the \gls{gatk}. This is done so that the reads generated as part of the PCR process don't add or subtract evidence for a putative variant during the variant calling stage.

```{bash, eval = FALSE}
java -Xmx30g -jar $EBROOTGATK/GenomeAnalysisTK.jar \
	-T BaseRecalibrator \
	-R $REF \
	-I $DIR/temp/${sample}_dedup_reads_${chr}.bam \
	-o $DIR/temp/${sample}_recal_data_${chr}.grp \
	-knownSites $DBSNP \
	-knownSites $MILLS \
	-knownSites $INDELS \
	-l INFO \
	-cov ReadGroupCovariate \
	-cov QualityScoreCovariate \
	-cov CycleCovariate \
	-cov ContextCovariate \
	-log $DIR/logs/${sample}_baserecal_${chr}.log \
	-L ${chr}
```

#### Base Recalibration

The bam files had the base recalibration step applied to account for platform specific base bias. The base quality is weighted highly in variant calling alogrithms, but different platforms have paticular inheirant systematic biases. The base recalibration step employs a machine learning approach to correct for these systematic errors.

```{bash, eval = FALSE}
java -Xmx30g -jar $EBROOTGATK/GenomeAnalysisTK.jar \
	-T BaseRecalibrator \
	-R $REF \
	-I $DIR/temp/${sample}_dedup_reads_${chr}.bam \
	-o $DIR/temp/${sample}_recal_data_${chr}.grp \
	-knownSites $DBSNP \
	-knownSites $MILLS \
	-knownSites $INDELS \
	-l INFO \
	-cov ReadGroupCovariate \
	-cov QualityScoreCovariate \
	-cov CycleCovariate \
	-cov ContextCovariate \
	-log $DIR/logs/${sample}_baserecal_${chr}.log \
	-L ${chr}
	
	java -Xmx30g -jar $EBROOTGATK/GenomeAnalysisTK.jar \
	-T PrintReads \
	-R $REF \
	-BQSR $DIR/temp/${sample}_recal_data_${chr}.grp \
	-I $DIR/temp/${sample}_dedup_reads_${chr}.bam \
	-o $DIR/final/${sample}_baserecal_reads_${chr}.bam \
	-l INFO \
	-log $DIR/logs/printreads_${chr}.log \
	-L ${chr} 
```

#### Haplotype caller - GVCF

The haplotype caller is used to call genetic variants. The haplotype caller is capable of calling \gls{snp}s and \gls{indel}s simulataneously by using de-novo local assembly. In GVCF mode the haplotype caller creates an intermediate genome \gls{vcf} (gVCF) file per sample. Each samples gVCF file is then able to be combined and all samples are then jointly genotyped together.

```{bash, eval = FALSE}
java -jar -Xmx30g ~/nesi00319/GATK3.6/nightly-19-11-2016/GenomeAnalysisTK.jar \
	-T HaplotypeCaller \
	-R $REF \
	-I $DIR/final/${sample}_baserecal_reads_${chr}.bam \
	-L ${chr} \
	--emitRefConfidence GVCF \
	--variant_index_type LINEAR \
	--variant_index_parameter 128000 \
	--dbsnp $DBSNP \
	-o $DIR/final/${sample}_${chr}.raw.snps.indels.g.vcf \
	-nct ${SLURM_JOB_CPUS_PER_NODE}


# combine gVCFs
parallel -j 22 '
  java -Xmx8g -jar \
    GATK/GenomeAnalysisTK-3.6/GenomeAnalysisTK.jar \
    -T CombineGVCFs \
    -R reference_files/FASTA/hs37d5/hs37d5.fa  \
    $(find ./ -name \*_{2}.raw*.g.vcf | tr "\n" " " |sed "s/ $//g" | sed "s/ / -V /g" |sed "s/^/ -V /g\") \
    -o ../combined_gvcf/{1}_{2}.raw.snps.indels.g.vcf \
    -log ../combined_gvcf/{1}_combine_{2}.log \
    -L {2} \
    && pigz -p 4 ../combined_gvcf/{1}_{2}.raw.snps.indels.g.vcf ' ::: man015 ::: $(seq 1 22)

# variant call gVCF
java -Xmx32g -jar \
  GATK/GenomeAnalysisTK-3.6/GenomeAnalysisTK.jar \
 -T GenotypeGVCFs \
 -R /Volumes/BiocArchive/archive/merrimanlab/reference_files/FASTA/hs37d5/hs37d5.fa \
 $(find ./combined_gvcf -name \*_{1}.raw*.g.vcf | tr "\n" " " |sed "s/ $//g" | sed "s/ / -V /g" |sed "s/^/ -V /g") \
 -o ./variant_called/man001-014_{1}.raw.snps.indels.vcf \
 -log ./variant_called/man001-014_combine_{1}.log \
 -L {1} -nt 20 && pigz -p 4 ./variant_called/man001-014_{1}.raw.snps.indels.vcf '  ::: $(seq 1 3)
```

#### Variant Recalibration

```{bash, eval = FALSE}
java -Xmx48g -jar \ 
  GATK/nightly-19-11-2016/GenomeAnalysisTK.jar \
  -T VariantRecalibrator \
  -R reference_files/FASTA/hs37d5/hs37d5.fa \
  $(find ./variant_called/  -name \*vcf | tr '\n' ' ' | sed 's/ $//g' | sed 's/\.\//-input \.\//g') \
  -resource:hapmap,known=false,training=true,truth=true,prior=15.0 \
  reference_files/resource_bundle_dec14/hapmap_3.3.b37.vcf \
  -resource:omni,known=false,traning=true,truth=false,prior=12.0 \
  reference_files/resource_bundle_dec14/1000G_omni2.5.b37.vcf \
  -resource:1000G,known=false,training=true,truth=false,prior=10.0 \
  reference_files/resource_bundle_dec14/1000G_phase1.snps.high_confidence.b37.vcf \
  -resource:dbsnp,known=true,training=false,truth=false,prior=2.0 \
  reference_files/resource_bundle_dec14/dbsnp_138.b37.vcf \
  -an QD -an MQ -an MQRankSum -an ReadPosRankSum -an FS -an SOR -an InbreedingCoeff \
  -mode SNP \
  -recalFile variant_recal/man001-014.SNP.recal \
  -tranchesFile variant_recal/man001-014.SNP.tranches \
  -rscriptFile variant_recal/man001-014.SNP.plots.R \
  -log variant_recal/man001-014.SNP.log
```
 
```{bash, eval = FALSE}
java -Xmx48g -jar \
  GATK/nightly-19-11-2016/GenomeAnalysisTK.jar \
  -T VariantRecalibrator \
  -R reference_files/FASTA/hs37d5/hs37d5.fa \
  $(find ./variant_called/  -name \*vcf | tr '\n' ' ' | sed 's/ $//g' | sed 's/\.\//-input \.\//g') \
  --maxGaussians 4 \
  -resource:mills,known=false,training=true,truth=true,prior=12.0 \
  reference_files/resource_bundle_dec14/Mills_and_1000G_gold_standard.indels.b37.vcf \
  -resource:dbsnp,known=true,training=false,truth=false,prior=2.0 \
  reference_files/resource_bundle_dec14/dbsnp_138.b37.vcf \
  -an QD -an DP -an FS -an SOR -an ReadPosRankSum -an MQRankSum -an InbreedingCoeff \
  -mode INDEL \
  -recalFile variant_recal/man001-014.INDEL.recal \
  -tranchesFile variant_recal/man001-014.INDEL.tranches \
  -rscriptFile variant_recal/man001-014.INDEL.plots.R \
  -log variant_recal/man001-014.INDEL.log
```
 
 Apply recalibration
```{bash, eval = FALSE}
for i in $(seq 1 22) 
do 
  java -Xmx12g  \
    -Djava.io.tmpdir=/Volumes/BiocArchive/archivetemp/java_tmp/ \
    -jar GATK/GenomeAnalysisTK-3.6/GenomeAnalysisTK.jar \
    -T ApplyRecalibration \
    -R  reference_files/FASTA/hs37d5/hs37d5.fa  \
    -input ./variant_called/man001-014_${i}.raw.snps.indels.vcf  \
    -mode SNP  \
    -recalFile ./variant_recal/man001-014.SNP.recal  \
    -tranchesFile ./variant_recal/man001-014.SNP.tranches  \
    -nt 4  \
    -L ${i} \
    -o ./variant_recal/man001-014_${i}.recal.snp.vcf  \
    --ts_filter_level 99.5  \
    -log ./variant_recal/man001-014_${i}.snp.applyrecal.log
done
 
for i in $(seq 1 22)
do
  java -Xmx12g \
    -Djava.io.tmpdir=/Volumes/BiocArchive/archivetemp/java_tmp/ \
    -jar GATK/GenomeAnalysisTK-3.6/GenomeAnalysisTK.jar \
    -T ApplyRecalibration \
    -R  reference_files/FASTA/hs37d5/hs37d5.fa \
    -input ./variant_recal/man001-014_${i}.recal.snp.vcf \
    -mode INDEL \
    -recalFile ./variant_recal/man001-014.INDEL.recal \
    -tranchesFile ./variant_recal/man001-014.INDEL.tranches \
    -nt 4 \
    -o ./variant_recal/man001-014_${i}.recal.snp.indel.vcf \
    --ts_filter_level 99.0 \
    -L ${i} \
    -log ./variant_recal/man001-014_${i}.indel.applyrecal.log
done
```

#### Genotype Concordence


### Variant Annotation

Variant annotation of \gls{vcf} files was performed using snpEff vXXX [@snpeff] with the homo sapiens GRCh37 database.


### Pathway Analysis


## Datasets

### 1000 Genomes Project Phase 3

<!--
@misc{1kgp_ftp,
keywords = {1KGP},
mendeley-groups = {PPARGC1Apaper,Datasets},
mendeley-tags = {1KGP},
title = {{1000 Genomes Project FTP}},
url = {ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/},
urldate = {2015-08-18}
}
-->

The \glsdesc{1kgp} was an international consortium that was established in 2007 to provide a comprehensive record of human genetic variation. The project consisted of three main data phases. A pilot phase that whole-genome sequenced 179 individuals from four populations at low coverage (2-4x), along with high coverage sequencing for two trios (mother, father, and child), and exon targeted sequencing for 697 individuals from seven populations [@1KGP2010]. The second main data phase provided sequencing data for 1092 individuals from 14 populations. This sequencing data was a combination of low coverage whole-genome and exon sequencing [@1KGP2012]. The third main phase (Phase 3) was a dataset consisting of low coverage whole-genome sequencing, deep exome sequencing, and dense microarray genotyping for 2504 individuals from 26 populations [@1KGP2015snp]. The 1000 Genomes data set used was the Phase 3 release^[ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ accessed 20 March 2017].


```{r populations, results = 'asis', echo = FALSE}
read.csv('~/Git_repos/SelectionDW_ETL/data/populations.csv', stringsAsFactors = FALSE) %>% filter(!pop %in% c("EPN","OMN","AXI","WPN","NAD") & superPop != "") %>% arrange(superPop, pop) %>% mutate(pop = if_else(pop %in% c("NZM","NZC","CIM","SAM","TON"), paste0(pop,'*'), pop))%>% select("Population" = pop, "Description" = description, "Genotype\nPlatform" = genotypePlatform) %>%   knitr::kable(format = 'latex', booktabs = TRUE, caption = '(\\#tab:populations) Description of Populations') %>% kableExtra::group_rows("African Super Population (AFR)", 1,7) %>% kableExtra::group_rows("Ad Mixed American Super Population (AMR)", 8, 11) %>% kableExtra::group_rows("East Asian Super Population (EAS)", 12, 16) %>% kableExtra::group_rows("European Super Population (EUR)", 17, 22) %>% kableExtra::group_rows("Polynesian Super Population (POL)*", 23, 26) %>% kableExtra::group_rows("South Asian Super Population (SAS)", 27, 31) %>% kableExtra::add_footnote("NZC, NZM, TON, SAM, and CIM are from 'Genetics of Aoteroa' and are not 1000 Genomes Project populations", notation = "symbol") %>% kableExtra::kable_styling(font_size = 8)
```


### Genetics of Gout in Aoteroa

The genetics of Gout in Aoteroa study is a case-control cohort with recruitment mainly from the Auckland, Wellington, Christchurch and Dunedin regions of New Zealand. Individuals were asked to fill in a questionaire regarding demographics information, clinical information, and food consumption at the time of recruitment. 

Individuals from this study were genotyped on Illumina CoreExome v24 microarray. A subset of individuals in this study were also whole genome sequenced at low coverage (XXX).



<!--
whole genome low-coverage resequenced, or exome resequence data.
#### Axiom

- about
- population

| | obs missing (n) | Māori AXIOM
---|---|---
Number | - | 71 
Sex (% male) | - | 64.7
Gout cases (%) | - | 49.3
Mean BMI (range) | 1 | 34.5 (22.1 to 56.1)
Diabetes (%) | 3 | 21.1
Mean grandparent ancestry (range) | - | 0.916 (0.625 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- markers
- density


#### Omni


| | obs missing (n) | Samoan OMNIexpress
---|---|---
Number | - | 96
Sex (% male) | - | 74
Gout cases (%) | - | 50.0
Mean BMI (range) | - | 36.1 (20.5 to 93.4)
Diabetes (%) | - | 12.5
Mean grandparent ancestry (range) | - | 0.997 (0.875 to 1.00)

Mean grandparent ancestry is the proportion of grandparents self-reported as belonging to the ethnicity group BMI body mass index


- about
- population
- markers
- density
-->
#### CoreExome

The Infinium CoreExome-24 beadchip is a genotyping platform available from Illumina. It comprises a core set of 551,839 markers with a mean density of XXX. Genotyping quality control was performed following the protocol from @Guo2014 and the Illumina GenomeStudio best practice guidelines. Illumina’s GenomeStudio v2011.1 genotyping module v1.9.4 was used for the initial calling of genotypes. Samples were exported from Genome Studio that had a call rate > 98%, markers were zeroed if they were < 95%. Inidivuals who had not reported their sex were assigned their genetic sex where possible. Individuals were removed where genetic and reported sex did not match. The cohort was checked for genotype consistency between duplicated markers, with duplicates subsequently removed.

Heterozygosity and depression of genetic variation was also checked for outliers.



Relatedness between individuals was assessed through inheritence by state using Plink2 (v1.9b3.32) and a pedigree of created to 
Duplicates and first degree relations were excluded.

Hardy-Weinberg equilibrium of markers was checked for European, East Polynesian, and West Polynesian populations (3 or more grandparents self reported ethnicity) using an exact test in plink2 and variants were removed that had a Bonferroni multiple testing corrected p < 0.05.

The genetic ancestry determined through \gls{pca} was compared with self reported ethnicity and individuals were removed where there was disagreement.





Selection of samples to form the populations used in the selection analyses
Gout affection was determined by the American College of Rheumatology criteria



A single individual was randomly selected from family groups identified through identity by state analysis. Individuals who had a mismatch between self reported and genetic ancestry were also removed. Principle components 2 and 4 were found to provide the greatest separation between Europeans, East Polynesians, and West Polynesians. Individuals reporting 4 grandparents of Caucasian, NZ Maori, CI Maori, Samoan, and Tongan ancestry were used to define the threshold values. Thresholds were calculated using mean +/- 2 SD for PC2 and PC4 for each population group. Once thresholds were calculated all samples were filtered so that only those that lay within a boundary remained. Remaining samples were then randomly sampled to form groups of 100 individuals, where possible trying to match general population prevalence for gout.

Marker Categories | Number of Markers
---|---
In RefSeq Genes | 374,258 (399,009 within 10 kb)
In RefSeq Exons | 269,186
In RefSeq Promoter Regions | 13,990
In ADME Genes | 11,276 (12,455 within 10 kb)
In ADME Exons | 9,314
MHC (Extended MHC) | 3,940 (5,628)
Overlap with Genes in COSMIC | 365,135
Overlap with Genes in Gene Ontology | 96,331
Nonsense Markers | 14,994
Missense Markers | 219,162
Synonymous Markers | 14,747
Silent Markers | 8,850
Mitochondrial Markers |351
Indels | 12,436

mean call rate
mean missing
number of snps passing qc
number of snps used for selection


(http://www.illumina.com/content/dam/illumina-marketing/documents/products/datasheets/datasheet_human_core_exome_beadchip.pdf, accessed 16 Jan 2017)


Clinical Information



\newpage
\blandscape



```{r clinInfoCE, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE}
pander::pandoc.table(ce_clinical_table(), caption = ' (\\#tab:clinInfoCE) Clinical information for each core Exome population', split.cells = 10 )
```

\elandscape
\newpage

The clinical info is contained in table \@ref(tab:clinInfoCE) which is printed somewhere


```{r, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE, eval = FALSE}
#knitr::kable(ce_populations_table(), longtable = TRUE, format = 'pandoc', booktabs = TRUE , caption = 'Clinical information for New Zealand Populations in selection analysis')
```


Pandoc version
```{r, echo = FALSE, results = 'asis', message = FALSE, warning=FALSE}
ce_pop_table <- ce_populations_table()
names(ce_pop_table) <- c("pop","n","Age","Sex (% Male)","BMI","Waist","Percent Diabetes","Percent Gout")
pander::pandoc.table(data.frame(ce_pop_table), caption = '(\\#tab:cePopTable) Clinical information for New Zealand Populations in selection analysis', split.tables = 80, style = 'multiline', justify = 'lcrrrrrr')
```

- about
- population
- markers
- density

Table \@ref(tab:cePopTable) shows the break down of 

#### Polynesian Sequences

<!--
n | ~90
mean coverage |  Y x
-->

### Reference datasets

#### Markdown table

Table: (\#tab:refDatasets) _Reference Datasets_

| Name | Date | URL |
|:-------------------------------|--------------------------|--------------------------------------------------------------|
|1000 Genomes Project Phase 3 release 5 |17 Sept 2014| |
|1000 Genomes Project Phase 3 release 5 |20 Mar 2017| http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ |
|1000 Genomes Phase 3 phased haplotypes |14 Dec 2014| https://mathgen.stats.ox.ac.uk/impute/1000GP_Phase3.html |
|Human Genome Reference FASTA | 5 Aug 2014 | ftp://ftp.1000genomes.ebi.ac.uk:21/vol1/ftp/technical/reference/phase2_reference_assembly_sequence/hs37d5.fa.gz |
|Human Ancestral Allele FASTA | 6 Aug 2014 | ftp://ftp.ensembl.org/pub/release-66/fasta/ancestral_alleles/homo_sapiens_ancestor_GRCh37_e66.tar.bz |


This used table \@ref(tab:refDatasets) for the stuff

\newpage


## Selection dataset {#selectionDataset}

### Sample selection

Principle components were calculated for all individuals genotyped on the coreExome mircoarray using SmartPCA (EIGENSOFT v6.0.1, see PCA section) using 2858 ancestry informative markers (@Guo2014 supplementary material). The first 10 eigenvectors were outputted, with no outlier removal or population size limit. Individuals were removed who did not match between self reported ethncity of grandparents and their genetic ancestry, or if they had self reported their ethnicity as unknown.

Principle component 2 was identifed as providing the best separation of European ancestry from Polynesian ancestry, and PC4 had the best separation of East Polynesian from West Polynesian populations. Individuals were then filtered for European or Polynesian ancestry. To determine the boundaries of the population groups, the mean +/- 1 sd for PC2 and 4 were used

```{r, fig.cap = '(ref:cePCA) XXX temp plot of PCAs for subject selection'}
knitr::include_graphics('images/02_methods/temp_pca_plot.png')
```


### Core Exome - Filter individuals and markers 

To create a data set to calculate selection statistics, a subset of the individuals genotyped on the Illumina CoreExome chip were combined with all of the individuals in the 1000 Genomes Project phase 3 release. Before the data sets could be combined there were a series of steps that were performed.

The first step was to indentify and remove individuals who had failed the QC, and keep only the individuals who had been selected through \gls{pca} and had a genotyping rate of at least 95%. Markers were filtered to remove \gls{indel}s so that only \gls{snp}s remained.

```{r, engine = 'bash', eval = FALSE}
parallel -j 11 '
  plink2 \
    --bfile src_data/QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff \
    --recode vcf \
    --out QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff.chr{} \
    --chr {} \
    --remove src_data/QC1_7-BlanketExclusions.txt \
    --keep coreExome_selection_keep_ids.txt \
    --allow-no-sex \
    --snps-only no-DI \
    --geno 0.95
    ' ::: $(seq 1 22)
```

The second step was to ensure that all the core Exome markers were normalised against the hs37d5 human reference. This was to make sure the REF/ALT alleles would match with the 1000 Genomes Project phase 3 for a successful merge after phasing and subject selection. Shapeit2 was then used to find SNP alleles that disagreed with the 1000 Genomes Project haplotype reference and phase the core Exome markers. This step also reduced markers to biallelic positions and removed duplicate positions.

```{r, engine = 'bash', eval = FALSE}
parallel -j 11 '
  bcftools norm \
    -N \
    --rm-dup any \
    --check-ref s \
    -f /Volumes/BiocArchive/archive/merrimanlab/reference_files/FASTA/hs37d5/hs37d5.fa \
    -O v QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff.chr{}.vcf | \
  bcftools view \
    -m 2 \
    -M 2  \
    -O z \
    -o QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.vcf.gz \
  ' ::: $(seq 1 22)

```

After normalisation, the vcf files were phased using the 1000 Genomes Project phase 3 reference haplotypes as described in section \@ref(phase).

### Merge NZ coreExome with 1000 Genomes Project

In order to efficiently merge the data sets, the intersection of the markers from the 1kgp dataset and the coreExome was found. This was done by extracting the marker positions and alleles from the coreExome data and then matching these to the marker positions extracted from the 1000 Genomes Project phase 3. The 1000 Genomes Project phase 3 markers were also filtered to remove non biallelic SNPs.

```{r, engine = 'bash', eval = FALSE}
# extract markers from core exome
parallel '
  zgrep \
    -v "^#" QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.phased.vcf.gz |\
    cut -f1,2,4,5 > coreExome_chr{}_biallelic_markers.txt 
    ' ::: $(seq 1 22)

# extract 1000 Genomes markers
# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5
parllel '
  bcftools view \
    -O v \
    -m 2 \
    -M 2 \
    -v snps \
    -o - \
    /Volumes/BiocArchive/archive/merrimanlab/reference_files/VCF/1000Genomes_vcf_files/Phase3_March2017/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz |\
  grep -v "^#" |\
  cut -f 1,2,4,5 > 1kgp_chr{}_biallelic_markers.txt 
  ' ::: $(seq 1 22)
```


An R script was created in order to merge the two marker lists based on chromosome position and the reference and alternate alleles 

```{r, eval=FALSE}
# on merriserver
ce_markers <- data.frame()
tmp_list <- list()
for(i in 1:22){
  tmp_list[[i]] <- read.table(file = paste0('/Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/NZ_coreExome/coreExome_chr',i,'_biallelic_markers.txt'), header=FALSE)
}
ce_markers <- do.call(rbind, tmp_list)

kg_markers <- data.frame()
tmp_list2 <- list()
for(i in 1:22){
  tmp_list2[[i]] <- read.table(file= paste0('/Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5/1kgp_chr',i,'_biallelic_markers.txt'), header=FALSE)
  tmp_list2[[i]] <-  tmp_list2[[i]][ tmp_list2[[i]][,2] %in% tmp_list[[i]][,2],]
 
  print(i)
}
kg_markers <- do.call(rbind, tmp_list2)
ce_kg <- merge(ce_markers, kg_markers, by = c("V1","V2","V3","V4"))
write.table(file = 'ce_1kg_matched_markers.txt', ce_kg[,c(1,2)], row.names = FALSE, col.names=FALSE, quote=FALSE)
```

Once the combined marker list was created, both the core exome and 1000 Genomes Project data sets had have their markers filtered to this consensus set.
```{r, engine = 'bash', eval = FALSE}
# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/Phase3_v5
# filter 1000 Genomes markers
parallel '
  bcftools view 
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.biallelic_ce_1kg_matched.vcf.gz \
    /Volumes/BiocArchive/archive/merrimanlab/reference_files/VCF/1000Genomes_vcf_files/Phase3_March2017/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz 
  ' ::: $(seq 1 22)


# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/NZ_coreExome/
# filter coreExome markers
parallel '
  bcftools view \
    -R ../ce_1kg_matched_markers.txt \
    -O z \
    -m 2 \
    -M 2 \
    -v snps \
    -o NZ_coreExome.chr{}.norm.phased.biallelic_ce_1kg_matched.vcf.gz \
    QC1_7-FullMerge1.0and1.1_ExDup_MattBrown_Czech-plus_correctAff_norm.chr{}.phased.vcf.gz 
  ' ::: $(seq 1 22)

# merge 1kgp and nz coreexome
# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/
parallel 
  'bcftools merge \
    -O z \
    -o NZ_1KGP.chr{}.phased.vcf.gz \
    Phase3_v5/ALL.chr{}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.biallelic_ce_1kg_matched.vcf.gz \
    NZ_coreExome/NZ_coreExome.chr{}.norm.phased.biallelic_ce_1kg_matched.vcf.gz 
  ' ::: $(seq 1 22)
```

Sample identifiers were then updated to match the panel file that describe the population and super population an individual belonged to.
```{r, engine = 'bash', eval = FALSE}
# working dir: /Volumes/BiochemXsan/scratch/merrimanlab/murray/working_dir/coreExome_selection/NZ_coreExome_1kgp/data/
for i in $(seq 1 22)
do 
  zcat NZ_1KGP.chr$i.phased.vcf.gz |\
  head -1000 |\
  grep '^#CHROM' |\
  cut -f10- |\
  tr '\t' '\n' |\
  awk -F "_" '{if(NF ==1 ) {print $1 "\t" $1}else{print $1"_"$2"\t" $2}}' |\
  bcftools reheader \
    -s /dev/stdin/ \
    -o NZ_1KGP.chr$i.phased.sample_updated.vcf.gz \
    NZ_1KGP.chr$i.phased.vcf.gz
done
```

